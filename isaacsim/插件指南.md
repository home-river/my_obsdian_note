# snippets（代码片段）
提供了用于开发 Isaac Sim 项目的代码片段（Snippets）。你可以通过简单的快捷键插入常用代码，避免重复书写。

- **Core (api)**: 提供 Isaac Sim 核心 API 的代码片段。
    
- **Core (prims)**: 提供与 USD Prim 相关的代码片段，适用于场景编辑。
    
- **Core (utils)**: 提供常用工具方法的代码片段。
    
- **SimulationApp**: 提供与仿真应用相关的代码片段，方便快速集成应用。
    
- **UI (utils)**: 提供与用户界面相关的工具代码片段。

## Core（api）
### Articulations（关节）
#### ArticulationGripper（抓手部分）
```python
from isaacsim.core.api.articulations import ArticulationGripper
```
**导入类定义**  
从 Isaac Sim 的核心 API 中载入 `ArticulationGripper` 类，以便后面创建抓手对象并调用其方法。

```python
articulation_gripper = ArticulationGripper(gripper_dof_names=gripper_dof_names)
```
**实例化抓手对象**

- `gripper_dof_names`：一个字符串列表，每个元素对应抓手中一个自由度（Degree of Freedom，DOF）的名称，比如左右两个指爪的关节名。
    
- 这行代码创建了 `ArticulationGripper` 的实例 `articulation_gripper`，内部会存储这些 DOF 名称，以及后续用于控制它们的索引、目标位置等信息。

**对应关系**：

- **模型中的关节名称**：这些是你在创建机械模型时（在 USD 文件或通过编程设置时）为每个关节指定的名字。
    
- **gripper_dof_names 中的名称**：这些名称与模型中的关节名称一一对应，它们将在后续代码中用于控制抓手的动作。

```python
articulation_gripper.apply_action(action=action)
```
**应用控制指令**

- `action`：通常是一个数值数组或张量，表示对每个 DOF 发出的控制信号（比如目标位置、力矩或速度命令）。
    
- `apply_action()` 方法会将这些信号转发给底层的物理仿真控制器，让抓手朝指定目标运动。

```python
closed_position = articulation_gripper.closed_position
```

**获取“闭合”位置常量**

- `closed_position` 通常是一个数值（或数组），表示抓手完全闭合时的标准关节角度／位置。
    
- 从实例属性中读取，方便后续在决策逻辑里与当前关节位置比较，或者用作动作命令的上界。


```python
dof_indices = articulation_gripper.dof_indices
```

**获取 DOF 索引列表**

- `dof_indices` 是一个整数列表，对应 `gripper_dof_names` 在 USD Stage（场景）或物理引擎中分配到的具体 DOF 索引。
    
- 拿到索引后，可以通过底层 API 直接按索引访问或修改关节状态。



```python
positions = articulation_gripper.get_positions()
```
**读取当前关节位置**

- `get_positions()` 方法返回当前时刻所有 DOF 的实际位置（关节角度或伸缩量），通常以数组形式给出。
    
- 可用于监控、日志记录，或者在需要“恢复”到某个姿态时做状态保存。



```python
velocities = articulation_gripper.get_velocities()
```
**读取当前关节速度**

- `get_velocities()` 方法返回当前所有 DOF 的速度值，同样以数组形式返回。
    
- 对“惯性补偿”或控制器调优（比如PD控制）非常有用。



```python
articulation_gripper.initialize(root_prim_path=root_prim_path,
                             articulation_controller=articulation_controller)
```
**初始化抓手对象**

- `root_prim_path`：USD Stage 中该抓手对应的根 Prim（关节体系根节点）的路径字符串，例如 `"/World/robot/gripper"`.
    
- `articulation_controller`：一个控制器实例（通常由更高级的控制框架提供），负责在仿真循环中下发控制命令、收集状态。
    
- `initialize()` 会将 `ArticulationGripper` 与 USD 场景和物理控制器关联起来，建立从高层 API 到底层仿真引擎的映射。



```python
open_position = articulation_gripper.open_position
```
**获取“张开”位置常量**

- `open_position` 与 `closed_position` 类似，表示抓手完全张开时各 DOF 的位置。
    
- 可用作动作指令下界，或者在策略里快速切换到“空”状态。


```python
articulation_gripper.set_positions(positions=positions)
```
**批量设置关节位置**

- 将之前通过 `get_positions()` 读取并保存在 `positions` 里的数值，再次写回到仿真中。
    
- 常用于场景重置、从检查点恢复状态，或在非控制回路（直接状态设定）中瞬时“跳转”到某个姿态。


```python
articulation_gripper.set_velocities(velocities=velocities)
```

**批量设置关节速度**

- 与 `set_positions()` 同理，将之前保存的速度值恢复到当前仿真状态。
    
- 对于需要保持连续运动或准确模拟惯性场景（比如录制回放、碰撞检测测试）非常有帮助。



#### articulationsubset（关节子集）
这是关节系统的子集，允许直接控制某部分关节而不是全部关节。


**导入 ArticulationSubset 类**
```python
from isaacsim.core.api.articulations import ArticulationSubset
```

这一行从 `isaacsim.core.api.articulations` 模块导入了 `ArticulationSubset` 类，它是 Isaac Sim 中用于操作和管理机器人关节系统子集的类。使用这个类，你可以仅控制 Articulation 系统中的某些关节，而不是整个关节系统。

**实例化 ArticulationSubset 对象**
```python
articulation_subset = ArticulationSubset(articulation=articulation, joint_names=joint_names)
```
**解读**：

- 你通过 `ArticulationSubset` 类实例化一个对象 `articulation_subset`。
    
- 这个实例化需要两个参数：
    
    - `articulation`：这是你想要操作的完整关节系统，通常是一个机器人或机械臂的关节系统。
        
    - `joint_names`：这是一个字符串列表，包含了你想要操作的关节名称。这些关节将作为子集进行控制。
        

**作用**：  
创建一个 `ArticulationSubset` 对象，表示从完整的 `articulation` 系统中提取出的部分关节（由 `joint_names` 提供）。


**应用动作**
```python
articulation_subset.apply_action()
```
**解读**：

- `apply_action()` 方法用于将控制动作应用到 `articulation_subset` 上。这个方法通常需要一些控制指令作为输入，例如位置、速度或力矩等。
    
- **注意**：此处的 `apply_action()` 方法并没有传入参数，实际使用时通常会传入特定的动作数据（例如目标位置）。
    

**作用**：  
这行代码是将一个控制指令（动作）应用到指定的关节子集上，通常是执行某个动作如闭合、抓取等。

**获取已应用的动作**
```python
applied_action = articulation_subset.get_applied_action()
```
**解读**：

- `get_applied_action()` 方法用于返回已经应用的控制动作。
    
- 这个动作通常是一个关于关节位置、速度、力矩等的命令，可以帮助你检查当前系统执行了什么动作。
    

**作用**：  
查询并返回当前 `articulation_subset` 上应用的动作，通常用于调试或确认动作是否正确应用。


**获取关节的作用力**
```python
joint_efforts = articulation_subset.get_joint_efforts()
```
**解读**：

- `get_joint_efforts()` 方法用于获取关节的作用力（即关节施加的力矩）。
    
- 这些力矩信息对机器人动态建模、碰撞检测和控制器调试等非常有用。
    

**作用**：  
获取指定关节子集上的力矩或控制力，用于了解关节的当前受力状态。


**获取关节的位置**

```python
joint_positions = articulation_subset.get_joint_positions()
```
**解读**：

- `get_joint_positions()` 方法返回关节的当前位置信息，通常是角度（对于旋转关节）或位移（对于滑动关节）。
    

**作用**：  
读取当前关节的位置信息，用于状态监控、反馈控制、调试等。

**获取关节子集的索引**

```python
joint_subset_indices = articulation_subset.get_joint_subset_indices()
```
**解读**：

- `get_joint_subset_indices()` 返回当前关节子集的索引。这些索引通常是内部用于高效访问和操作关节数据的数字表示。
    

**作用**：  
用于获取关节子集在完整关节系统中的位置索引，有助于对关节的快速定位和访问。

**获取关节的速度**

```python
joint_velocities = articulation_subset.get_joint_velocities()
```
**解读**：

- `get_joint_velocities()` 返回当前关节子集的速度数据，通常是各关节的角速度或线速度。
    
- 这对于动态控制、控制器调节（如 PID 控制）非常重要。
    

**作用**：  
读取关节的运动速度，常用于控制和调节关节的行为，特别是在运动规划中。

**获取关节的状态**

```python
joints_state = articulation_subset.get_joints_state()
```
**解读**：

- `get_joints_state()` 方法返回关节的综合状态，可能包括关节的位置、速度、力矩等信息。
    
- 这个方法通常返回一个包含多个属性的复合对象，适合用来查看多个关节的状态。
    

**作用**：  
获取关节子集的综合状态信息，通常用于完整的反馈控制或者仿真结果分析。

**检查是否已初始化**

```python
is_initialized = articulation_subset.is_initialized
```
**解读**：

- `is_initialized` 属性用于检查该关节子集是否已经被初始化。初始化意味着该子集已经与场景中的关节系统建立了连接，能够正常工作。
    

**作用**：  
检查 `articulation_subset` 是否已经初始化，通常用于确保你在执行其他操作之前，子集已经准备好并能够正常运行。

**获取关节的索引**

```python
joint_indices = articulation_subset.joint_indices
```
**解读**：

- `joint_indices` 属性返回关节子集中的各个关节在 `articulation` 系统中的索引，便于在系统中高效管理和定位这些关节。
    

**作用**：  
获取关节子集的索引，用于在内部算法中快速查找和引用特定关节。

**创建关节操作**

```python
value =articulation_subset.make_articulation_action(
							joint_positions=joint_positions, 
							joint_velocities=joint_velocities)
```
**解读**：

- `make_articulation_action()` 用于创建一个新的关节操作，通常是基于指定的关节位置和速度。
    
- 这个操作可以在仿真或控制过程中使用，用来指定关节应执行的动作。
    

**作用**：  
生成一个新的动作，基于关节的目标位置和速度，可以在仿真中执行该动作。

**映射到关节顺序**

```python
value = articulation_subset.map_to_articulation_order(joint_values=joint_values)
```
**解读**：

- `map_to_articulation_order()` 用于将关节值映射到实际的关节顺序。这通常用于保证动作数据的顺序与物理系统中的关节顺序一致。
    

**作用**：  
将关节值（位置、速度等）映射到物理系统中的实际关节顺序，确保控制命令和仿真系统的匹配。



 **获取关节数目**


```python
num_joints = articulation_subset.num_joints
```

**解读**：

- `num_joints` 属性返回关节子集中的关节数量。这有助于理解当前子集涉及的关节数量，并在程序中做出相应调整。
    

**作用**：  
获取当前关节子集的关节数目，通常用于控制和资源管理。

---

**设置关节的作用力**

```python
articulation_subset.set_joint_efforts(efforts=efforts)
```

**解读**：

- `set_joint_efforts()` 用于设置关节的作用力，通常是关节的力矩（即驱动力）。
    
- `efforts` 参数是一个数组，包含了每个关节应施加的力。
    

**作用**：  
设置关节子集的力矩或驱动力，用于控制或调整关节的运动。

---

 **设置关节的位置**


```python
articulation_subset.set_joint_positions(positions=positions)
```

**解读**：

- `set_joint_positions()` 用于设置关节的位置，通常是指定目标位置，关节将朝这个目标位置运动。
    
- `positions` 是一个数组，包含每个关节的目标位置。
    

**作用**：  
设置关节的目标位置，用于控制关节的姿态。

---

**设置关节的速度**

```python
articulation_subset.set_joint_velocities(velocities=velocities)`
```

**解读**：

- `set_joint_velocities()` 用于设置关节的速度，通常是指定关节应以某种速度运动。
    
- `velocities` 是一个数组，包含每个关节的目标速度。
    

**作用**：  
设置关节的目标速度，用于控制关节的运动速率。


### controller（控制器）
`isaacsim.core.api.controllers` 模块是与 **控制器（Controller）** 相关的功能部分。控制器是机器人或机械系统中的核心组件之一，负责根据设定的目标（如位置、速度、力矩等）生成控制命令，并通过物理引擎将这些命令传递给机器人关节，从而使得机器人能够按照预定的行为进行运动。

#### ArticulationController
`ArticulationController` 是 **Isaac Sim** 中一个关键的控制器类，它专门用于控制多关节系统（例如机器人臂、机械装置等）。这个控制器主要用于操作和控制由多个关节组成的机器人系统，通过控制机器人关节的位置、速度、力矩等，以实现所需的动作。

**导入模块**
```python
from isaacsim.core.api.controllers import ArticulationController
```

**解读**：  
这行代码从 **Isaac Sim** 的控制器模块导入了 `ArticulationController` 类。这个控制器类用于控制多关节系统，如机器人臂，支持多种控制模式（位置、速度、力矩控制等）。

---

**创建控制器实例**
```python
articulation_controller = ArticulationController()
```

**解读**：  
创建一个 `ArticulationController` 对象 `articulation_controller`，用于控制机器人或机械臂的关节动作。

---

**应用控制动作**
```python
articulation_controller.apply_action(control_actions=control_actions)
```

**解读**：

- `apply_action()` 方法用于将控制动作 `control_actions` 应用到关节系统上。
    
- `control_actions` 是一个`ArcticulationAction`对象，它包含以下字段：

	- **`joint_positions`**：一个数组或张量，表示关节的目标位置。这个字段是可选的，可以为 `None`，如果没有提供该字段，默认不会应用位置控制。
    
	- **`joint_velocities`**：一个数组或张量，表示关节的目标速度。这个字段也是可选的，可以为 `None`，如果没有提供该字段，默认不会应用速度控制。
    
	- **`joint_efforts`**：一个数组或张量，表示关节的目标力矩（efforts）。如果没有提供该字段，默认会将力矩设为零。
    
	- **`joint_indices`**：一个可选的数组，表示指定的关节自由度（DOF）的索引，用于选择应用控制动作的关节。如果为 `None`，则默认应用于所有关节自由度。
    

**示例**：
```python
control_actions = [0.5, 0.2, -0.3]  # 目标位置、速度或力矩 articulation_controller.apply_action(control_actions=control_actions)
```

---

**获取已应用的控制动作**

```python
applied_action = articulation_controller.get_applied_action()
```

**解读**：  
`get_applied_action()` 返回当前已应用的控制动作。它帮助用户检查当前控制系统执行了哪些动作。

---

**获取关节的控制模式**
```python
effort_modes = articulation_controller.get_effort_modes()
```

**解读**：  
`get_effort_modes()` 返回关节的当前控制模式，通常是指力矩控制模式（Effort Mode）。它表示每个关节在控制过程中是否应用了力矩控制。

---

**获取控制器增益**
```python
gains = articulation_controller.get_gains()
```

**解读**：  
`get_gains()` 返回当前控制器的增益值，通常用于 PID 控制算法中。这些增益值调节了控制器对误差的响应。

---

 **获取关节的运动限制**

```python
joint_limits = articulation_controller.get_joint_limits()
```

**解读**：  
`get_joint_limits()` 返回关节的位置和速度限制，确保机器人关节在物理允许的范围内运动，防止超出最大角度或速度。

---

  **获取最大力矩**
```python
max_efforts = articulation_controller.get_max_efforts()
```

**解读**：  
`get_max_efforts()` 返回各关节可承受的最大力矩，防止关节或执行器施加过大力矩造成损坏。

---

 **初始化控制器**
```python
articulation_controller.initialize(articulation_view=articulation_view)
```

**解读**：  
`initialize()` 方法将控制器与具体的关节视图（`articulation_view`）进行绑定。`articulation_view` 是一个表示多关节系统的视图，控制器需要与该视图关联才能执行控制。

---

**设置力矩控制模式**
```python
articulation_controller.set_effort_modes(mode=mode)
```

**解读**：  
`set_effort_modes()` 用于设置所有关节的力矩控制模式为 `mode`。`mode` 可以是力矩控制（如 'torque'）或其他类型的模式。

**示例**：
```python
mode = 'torque' 
articulation_controller.set_effort_modes(mode=mode)
```

---

 **设置控制器增益**
```python
articulation_controller.set_gains()
```

**解读**：  
`set_gains()` 方法设置控制器的增益，通常用于控制算法（如 PID 控制器），调整机器人的响应速度、稳态误差等。

---

 **设置最大力矩**
```python
articulation_controller.set_max_efforts(values=values)
```

**解读**：  
`set_max_efforts()` 设置每个关节的最大允许力矩（efforts），防止关节过度负荷。

**示例**：
```python
values = [5.0, 10.0, 15.0]  # 每个关节的最大力矩 articulation_controller.set_max_efforts(values=values)
```

---

 **切换控制模式**
```python
articulation_controller.switch_control_mode(mode=mode)
```

**解读**：  
`switch_control_mode()` 切换整个系统的控制模式。`mode` 可以是 `position`（位置控制）、`velocity`（速度控制）、`effort`（力矩控制）等。

**示例**：
```python
mode = 'position'
articulation_controller.switch_control_mode(mode=mode)
```

---

 **切换特定关节的控制模式**
```python
articulation_controller.switch_dof_control_mode(dof_index=dof_index, mode=mode)
```

**解读**：  
`switch_dof_control_mode()` 用于切换某个具体自由度（DOF，通常是一个关节）的控制模式。`dof_index` 是关节的索引，`mode` 是要切换到的控制模式（如 `position`、`velocity` 或 `effort`）。

**示例**：
```python
dof_index = 0  # 第一个关节
mode = 'effort'  # 设置为力矩控制模式
articulation_controller.switch_dof_control_mode(dof_index=dof_index, mode=mode)
```


#### BaseController
它是一个抽象控制器类，所有具体的控制器类都应该继承自它，并实现 `forward` 方法。`BaseController` 作为基类，提供了控制器的基础框架和部分功能，继承它的子类会扩展并实现具体的控制逻辑。

1. **导入 `BaseController`**
```python
from isaacsim.core.api.controllers import BaseController
```

**解读**：

- 这行代码导入了 **`BaseController`** 类，它是一个抽象的基类，用于定义控制器的基本结构。
    
- `BaseController` 类通常是其他控制器（如 `ArticulationController`）的父类。具体的控制逻辑会在继承自 `BaseController` 的类中实现。
    

---
2. **创建 `BaseController` 实例**

```python
base_controller = BaseController(name=name)
```

**解读**：

- **`BaseController(name=name)`**： 这行代码创建了一个 `BaseController` 实例，并传入了一个名为 `name` 的参数。`name` 可能是控制器实例的名称或标识符，用于区分不同的控制器实例。
    
- **`name` 参数**：`name` 是用于标识控制器的字符串参数，可能在调试、日志记录或者用户界面中用于识别不同的控制器。
    
    但是，值得注意的是，`BaseController` 是一个 **抽象类**，不能直接实例化，因此在实际的使用中，这一行代码通常会抛出 `TypeError`，除非 `BaseController` 已经被某个具体类（如 `ArticulationController`）继承并实现了所有必要的方法。
    
---

3. **调用 `forward()` 方法**

```python
value = base_controller.forward()
```

**解读**：

- **`forward()`**：`forward` 是一个抽象方法，在 `BaseController` 中没有实现，必须在继承的子类中实现。该方法的目的是接受输入（如传感器观测数据、当前状态等），并生成控制动作（通常是 `ArticulationAction` 对象）。控制动作会传递给下层的控制系统（如 `ArticulationController`）。
    
- **返回值**：`forward()` 方法返回的是一个 **`ArticulationAction`** 对象，表示要执行的控制动作，通常包括关节位置、速度和力矩等。`value` 将存储这个返回的控制动作。
    
    **示例**：
    
```python
class MyController(BaseController):   
	def forward(self, observations: dict) -> ArticulationAction:         
		joint_positions = observations["joint_positions"]         
		return ArticulationAction(joint_positions=joint_positions)
		
controller = MyController(name="MyController") 
observations = {"joint_positions": [0.5, 0.3, -0.2]} 
value = controller.forward(observations)
```
在这个例子中，`forward` 方法会返回一个 `ArticulationAction` 对象，包含目标关节位置。
    
- **注意**：因为 `BaseController` 是抽象类，因此 `forward()` 方法在 `BaseController` 中没有实际实现。要使用这个方法，必须在继承类中实现具体的控制逻辑。
    

---

4. **调用 `reset()` 方法**
```python
base_controller.reset()
```

**解读**：

- **`reset()`**：`reset` 方法用于重置控制器的状态。通常，这会清除控制器中的任何累积状态或数据，恢复到初始状态，准备进行下一次控制。
    
- 在 `BaseController` 类中，`reset()` 方法没有具体实现，但它会在继承类中进行实现，通常用于重置控制器的内部状态、清除历史数据、重置机器人状态等。
    
    **示例**：  
    如果在 `MyController` 中实现了 `reset()` 方法，它可能会清除某些控制参数或重置关节位置：
    
```python
class MyController(BaseController):
    def forward(self, observations: dict) -> ArticulationAction:
        joint_positions = observations["joint_positions"]
        return ArticulationAction(joint_positions=joint_positions)

    def reset(self):
        self._last_position = [0.0, 0.0, 0.0]

```
在这个例子中，`reset()` 方法清除了控制器的 `last_position` 状态。


#### BaseGripperController
继承自 `BaseController`，专门用于控制机械臂的抓手（gripper）。该类提供了一个用于操作抓手的方法（如打开、闭合），并定义了一个框架，用于具体的抓手控制类（例如 `GripperController`）进行继承和实现。

1. **创建 `BaseGripperController` 实例**
```python
base_gripper_controller = BaseGripperController(name=name)
```

**解读**：

- 这行代码尝试实例化 `BaseGripperController` 类并传递 `name` 参数。
    
- **问题**：`BaseGripperController` 是一个 **抽象类**，不能直接实例化，因此此行代码在实际运行时会抛出 `TypeError`，除非你已经定义了一个继承 `BaseGripperController` 的具体子类（例如 `GripperController`）并实现了所有抽象方法。
    
- `name` 是控制器实例的名称，用于标识该控制器。
    

2. **调用 `close()` 方法**

```python
value=base_gripper_controller.close(
current_joint_positions=current_joint_positions)
```

**解读**：

- 这行代码调用了 `close()` 方法，传入当前的关节位置（`current_joint_positions`）。
    
- **问题**：`close()` 是一个抽象方法，在 `BaseGripperController` 中没有具体实现，因此这行代码会抛出 `NotImplementedError`，除非该方法在子类中被实现。子类需要提供抓手闭合的具体实现。
    
- `current_joint_positions` 是一个 NumPy 数组，表示当前抓手的关节位置。

**意义**：

- **抓手闭合**：与 `open()` 方法相对应，`close()` 方法表示控制器执行抓手闭合的操作。它计算当前抓手的关节位置（`current_joint_positions`）并生成一个新的控制指令来闭合抓手。
    
- **抽象实现**：与 `open()` 方法一样，`close()` 是一个抽象方法，子类需要实现这个方法来定义如何通过关节的控制来闭合抓手。
    
- **返回控制动作**：和 `open()` 一样，`close()` 方法返回一个 **`ArticulationAction`** 对象，表示闭合抓手所需的关节控制动作。

3. **调用 `forward()` 方法**
```python
value = base_gripper_controller.forward(action=action, current_joint_positions=current_joint_positions)
```

**解读**：

- 这行代码调用了 `forward()` 方法，传入了 `action`（动作类型，通常是 `"open"` 或 `"close"`）和 `current_joint_positions`（当前关节位置）。
    
- **问题**：`forward()` 方法是一个抽象方法，在 `BaseGripperController` 中没有具体实现，因此这行代码同样会抛出 `NotImplementedError`，除非在子类中实现了该方法。该方法会基于 `action` 执行抓手的操作，并返回一个控制动作（通常是 `ArticulationAction`）。
    
    例如，子类可能会实现 `forward()` 来决定是打开还是闭合抓手。


**意义**：

- **控制系统的核心计算**：`forward()` 方法是控制器的核心方法之一，通常用于接收当前状态并计算下一个控制动作。它通常会接收从传感器、外部输入或者内部计算得出的状态信息，并根据这些信息决定机器人的行为。
    
- **动作决策**：在该方法中，控制器根据传入的 `action`（例如 "open" 或 "close"）和当前的 `current_joint_positions`（关节的当前位置）来决定下一步应该如何控制抓手的运动。例如，"open" 操作会使抓手张开，"close" 操作会使抓手闭合。
    
- **返回控制动作**：`forward()` 方法通常会生成并返回一个 **`ArticulationAction`** 对象，表示控制指令（如目标位置、速度等），这些指令会被传递给机器人执行。
    

4. **调用 `forward()` 方法（无参数）**
```python
value = base_gripper_controller.forward()
```

**解读**：

- 这行代码再次调用了 `forward()` 方法，但没有传递任何参数。由于 `forward()` 是一个抽象方法，且在 `BaseGripperController` 中没有实现，因此这行代码会抛出 `NotImplementedError`，要求在子类中实现该方法。
    
    正常情况下，`forward()` 应该接收如 `action` 和 `current_joint_positions` 之类的参数。如果没有提供参数，可能会引发错误，或者根据设计，`forward()` 需要设置一些默认行为。
    

5. **调用 `open()` 方法**

```python
value = base_gripper_controller.open(current_joint_positions=current_joint_positions)
```

**解读**：

- 这行代码调用了 `open()` 方法，传入了当前的关节位置（`current_joint_positions`）。
    
- **问题**：`open()` 是一个抽象方法，在 `BaseGripperController` 中没有实现，因此这行代码会抛出 `NotImplementedError`。子类必须实现 `open()` 方法，定义抓手的具体打开操作，并返回一个 **`ArticulationAction`**（表示控制指令）。
    
**意义**：

- **抓手打开**：`open()` 方法通常表示一个具体的操作，用来指示控制器执行抓手的打开动作。它通过计算当前关节的位置（`current_joint_positions`）来决定抓手的动作，从而改变抓手的状态（通常是让抓手张开）。
    
- **抽象实现**：在 `BaseGripperController` 中，`open()` 是一个抽象方法，意味着没有给出具体的实现。子类（如具体的抓手控制器）需要提供实现，告诉控制器如何通过给定的关节位置打开抓手。
    
- **返回控制动作**：返回一个 **`ArticulationAction`** 对象，描述抓手打开所需的关节控制动作（例如目标位置、速度等）。


6. **调用 `reset()` 方法**

```python
base_gripper_controller.reset()
```

**解读**：

- 这行代码调用了 `reset()` 方法，通常用于将控制器的状态重置为初始状态。在 `BaseGripperController` 中，`reset()` 没有实际实现，因此这个调用不会做任何事情。如果在子类中有实现 `reset()`，它可能用于重置控制器的内部状态，或恢复抓手到默认状态。


---

### DataLogger
`DataLogger` 类用于收集、存储和读取仿真过程中产生的数据。它提供了数据的记录、暂停、恢复、重置等功能，并支持将数据保存到 JSON 文件中，也可以从 JSON 文件中加载已保存的数据。

使用前需要使用下面的语句导入`DataLogger`类
```python
from isaacsim.core.api.loggers import DataLogger
```

1. **创建 `DataLogger` 实例**
```python
data_logger = DataLogger()
```

**解读**：

- **创建 `DataLogger` 实例**：这行代码创建了一个 `DataLogger` 类的实例，名为 `data_logger`，用于收集和管理仿真数据。此对象将用于存储每个时间步的仿真数据，并能够控制数据记录的开始、暂停、保存和加载。
    

---

2. **添加数据到日志**
```python
data_logger.add_data(data=data, current_time_step=current_time_step, current_time=current_time)
```
**解读**：

- **`add_data()`**：此方法将新的数据添加到日志中，并将其保存在数据帧（`DataFrame`）中。
    
- **参数**：
    
    - `data`：表示要添加的数据，通常是一个字典，包含当前仿真步骤的数据。
        
    - `current_time_step`：当前的仿真时间步，通常是一个整数或浮动的数值，表示仿真进行的时间步。
        
    - `current_time`：当前的仿真时间，通常以秒为单位，表示仿真开始到当前的时间。
        
    
    **功能**：这行代码会将数据、时间步和时间信息作为一个 `DataFrame` 对象存储到 `data_logger` 的内部列表中。每个数据帧记录一个时间步的数据。
    

---

3. **添加数据帧日志函数**
```python
data_logger.add_data_frame_logging_func(func=func)
```

**解读**：

- **`add_data_frame_logging_func()`**：这个方法允许用户为 `DataLogger` 注册一个回调函数 `func`，该函数将在每个时间步被调用来收集数据。
    
- **参数**：
    
    - `func`：一个函数，签名为 `func(tasks, scene)`，它接收当前仿真任务和场景对象，返回一个字典，表示收集到的数据。
        
    
    **功能**：每次数据记录时，`DataLogger` 会调用这个 `func` 函数来获取当前的仿真数据。这使得用户可以在每个时间步动态地收集数据。
    

---

4. **获取指定的数据帧**

```python
data_frame = data_logger.get_data_frame(data_frame_index=data_frame_index)
```

**解读**：

- **`get_data_frame()`**：该方法从 `DataLogger` 中获取指定索引的数据帧。
    
- **参数**：
    
    - `data_frame_index`：指定的数据帧的索引。
        
    
    **返回值**：返回指定索引的 `DataFrame` 对象，包含该时间步的数据、时间步和时间信息。
    
    **功能**：用户可以使用此方法获取记录的数据帧，进行分析或调试。
    

---

5. **获取数据帧的数量**

```python
num_of_data_frames = data_logger.get_num_of_data_frames()
```

**解读**：

- **`get_num_of_data_frames()`**：该方法返回当前已收集的数据帧的数量。
    
    **返回值**：返回一个整数，表示当前记录的所有数据帧的数量。
    
    **功能**：用于检查当前记录的数据量，确认是否收集了足够的数据。
    

---
6. **检查数据收集是否已开始**

```python
value = data_logger.is_started()
```

**解读**：

- **`is_started()`**：该方法返回一个布尔值，表示数据收集是否已启动。
    
    **返回值**：
    
    - `True`：如果数据收集已开始或恢复。
        
    - `False`：如果数据收集处于暂停状态。
        
    
    **功能**：该方法可用于检查数据是否已经开始记录。
    

---
7. **从文件加载数据**


```python
data_logger.load(log_path=log_path)
```
**解读**：

- **`load()`**：该方法用于从指定的文件路径加载先前保存的数据。
    
- **参数**：
    
    - `log_path`：要加载的 JSON 文件路径。
        
    
    **功能**：从保存的数据文件中恢复数据，通常用于继续仿真或从之前的记录中读取数据。加载后，数据收集会从文件恢复的状态继续。
    

---
8. **暂停数据收集**

```python
data_logger.pause()
```

**解读**：

- **`pause()`**：该方法用于暂停数据收集。
    
    **功能**：暂停数据记录。这意味着数据不会被进一步收集，直到调用 `start()` 方法恢复收集。
    

---
9. **重置数据日志**

```python
data_logger.reset()
```

**解读**：

- **`reset()`**：该方法重置数据日志，清除所有已记录的数据，并暂停数据收集。
    
    **功能**：当需要从头开始新的数据记录时，使用此方法重置数据。所有先前收集的数据将被清空，准备重新开始收集数据。
    

---
10. **保存数据到文件**

```python
data_logger.save(log_path=log_path)
```

**解读**：

- **`save()`**：该方法将当前的收集数据保存到指定路径的 JSON 文件中。
    
- **参数**：
    
    - `log_path`：保存日志的目标文件路径。
        
    
    **功能**：将当前所有收集到的数据（存储在 `self._data_frames` 中）保存到文件中。此文件可以用于后续的加载或分析。
    
---
11. **开始数据收集**

```python
data_logger.start()
```

**解读**：

- **`start()`**：该方法用于恢复或启动数据收集。
    
    **功能**：如果数据收集已经暂停，调用此方法会恢复数据收集。如果之前没有开始过数据收集，它将启动数据收集。


### Material
在 **Isaac Sim** 中，`material` 模块通常涉及物理仿真中的材料属性的设置，尤其是与仿真物体的表面属性（如摩擦、反射、光泽等）相关。材料模块可以控制物体如何与其他物体交互，包括它们在仿真中的物理表现、外观和碰撞行为。

#### `DeformableMaterial(可变型材料)`
`DeformableMaterial`定义了一个用于模拟软体物体（如柔性材料或软体物体）在 Isaac Sim 中的变形材料类 。它通过使用 NVIDIA 的 PhysX 和 USD（Universal Scene Description）框架来处理物理属性，并将这些物理属性应用到指定路径的 USD prim（物体原型）上。

1. **导入 `DeformableMaterial`**

```python
from isaacsim.core.api.materials import DeformableMaterial
```

- 这行代码导入了 `DeformableMaterial` 类，允许在代码中创建并使用该类来操作变形材料。
    
---

2. **创建 `DeformableMaterial` 实例**

```python
deformable_material = DeformableMaterial(prim_path=prim_path)
```

- 这一行代码创建了一个 `DeformableMaterial` 对象 `deformable_material`。`prim_path` 是指定的 USD prim 路径，表明这个材料会应用到此路径下的物体。
    

---

3. **获取 `damping_scale`**

```python
damping_scale = deformable_material.get_damping_scale()
```

- 通过调用 `get_damping_scale()` 方法，获取当前变形材料的阻尼缩放系数 (`damping_scale`)。该系数描述了材料的阻尼效应，控制能量损耗的速率。
    
---

4. **获取 `dynamic_friction`**

```python
dynamic_friction = deformable_material.get_dynamic_friction()
```
- 调用 `get_dynamic_friction()` 方法获取当前的动态摩擦系数。该系数控制物体在相互作用时的摩擦力。
    
---

5. **获取 `elasticity_damping`**

```python
elasticity_damping = deformable_material.get_elasticity_damping()
```

- 使用 `get_elasticity_damping()` 获取当前的弹性阻尼系数。该系数控制物体在变形过程中的弹性恢复速率。
    
---

6. **获取 `poissons_ratio`**

```python
poissons_ratio = deformable_material.get_poissons_ratio()
```

- 通过 `get_poissons_ratio()` 获取当前的泊松比，描述材料在拉伸时其横向收缩的比率。
    

---

 7. **获取 `youngs_modululs`**

```python
youngs_modululs = deformable_material.get_youngs_modululs()
```

- 调用 `get_youngs_modululs()` 获取当前的杨氏模量，这个值控制材料的刚度，决定其在受力下的变形程度。
    

8. **初始化材料**
```python
deformable_material.initialize()
```

- 该行代码调用 `initialize()` 方法，初始化 `DeformableMaterial` 对象。这通常用于在仿真中准备该材料，使其开始参与物理仿真计算。
    

9. **检查 `DeformableMaterial` 是否有效**

```python
value = deformable_material.is_valid()
```

- 调用 `is_valid()` 方法检查当前 `DeformableMaterial` 对象是否有效。返回值 `value` 是一个布尔值，表示该对象是否有效（即对应的 USD prim 是否有效）。
    

10. **获取 `material` 对象**


```python
material = deformable_material.material
```

- 通过 `material` 属性，获取与该变形材料对象相关的 USD 材料对象。这个对象代表了物理材料的定义。
    

11. **获取 `name`**

```python
name = deformable_material.name
```

- 调用 `name` 属性获取 `DeformableMaterial` 对象的名称。如果没有显式设置名称，则返回 `None`。
    

12. **重置材料**

```python
deformable_material.post_reset()
```

- `post_reset()` 方法用于将 `DeformableMaterial` 对象的状态恢复到默认状态。一般来说，恢复到最初的物理状态。
    

13. **获取 `prim` 对象**

```python
prim = deformable_material.prim
```

- 通过 `prim` 属性获取当前变形材料对象的 USD prim。这个 prim 是在 USD Stage 中对应的物体原型，可以对其进行操作。
    

14. **获取 `prim_path`**

```python
prim_path = deformable_material.prim_path
```

- 使用 `prim_path` 属性获取变形材料对应的 prim 路径。这是一个字符串，表示在 USD Stage 中的物体位置。
    

15. **设置 `damping_scale`**

```python
deformable_material.set_damping_scale(value=value)
```

- 通过 `set_damping_scale()` 方法设置新的阻尼缩放系数。`value` 是你希望设置的系数值。
    

16. **设置 `dynamic_friction`**

```python
deformable_material.set_dynamic_friction(value=value)
```

- 使用 `set_dynamic_friction()` 方法设置新的动态摩擦系数。`value` 是你希望设置的系数值。
    

17. **设置 `elasticity_damping`**

```python
deformable_material.set_elasticity_damping(value=value)
```

- 通过 `set_elasticity_damping()` 方法设置新的弹性阻尼系数。`value` 是你希望设置的系数值。
    

18. **设置 `poissons_ratio`**

```python
deformable_material.set_poissons_ratio(value=value)
```

- 使用 `set_poissons_ratio()` 方法设置新的泊松比。`value` 是你希望设置的系数值。
    

19. **设置 `youngs_modululs`**


```python
deformable_material.set_youngs_modululs(value=value)
```

- 通过 `set_youngs_modululs()` 方法设置新的杨氏模量。`value` 是你希望设置的系数值。


#### `DeformableMaterialView`
**模块定位**  
`DeformableMaterialView` 用于 Isaac Sim 中批量管理符合给定 USD 路径正则的可变形材质。它统一封装了编辑模式（USD API）与仿真模式（PhysX 张量视图）下，对摩擦、弹性、阻尼、泊松比、杨氏模量等属性的高效读写。

---

**核心属性**

- `count` (int, property)：匹配到的材质数量。
    
- `name` (str, property)：构造时指定的视图名称。
    
- `_prim_paths` (List[str])：匹配到的 USD Prim 路径列表。
    
- `_prims` (List[Usd.Prim])：对应的 USD Prim 对象列表。
    
- `_regex_prim_paths` (str)：用于物理视图创建的正则表达式（`.`*→`*`）。
    
- `_backend` / `_backend_utils`：Torch 或 NumPy 张量后端及其工具。
    
- `_device` (str)：运行设备，编辑态固定为 `"cpu"`。
    
- `_material_apis` (List[PhysxDeformableBodyMaterialAPI | None])：编辑模式下延迟附加的材质 API。
    
- `_physics_sim_view` (SimulationView)：物理仿真视图实例（在 `initialize` 后存在）。
    
- `_physics_view` (SoftBodyMaterialView)：物理模式下的软体材质批量张量视图。
    

---

**全部接口**

> **生命周期**
> 
> - `__init__(prim_paths_expr: str, name: str = ..., dynamic_frictions=None, youngs_moduli=None, poissons_ratios=None, elasticity_dampings=None, damping_scales=None)`  
>     构造并缓存 Prim；选择后端；可选批量初始化各属性。
>     
> - `initialize(physics_sim_view: SimulationView = None) -> None`  
>     创建或接收仿真视图，生成软体材质张量视图并更新 `count`。
>     
> - `post_reset() -> None`  
>     仿真重置时的占位钩子，预留用于恢复初始状态（当前未实现）。
>     
> - `_invalidate_physics_handle_callback(event) -> None`  
>     Timeline 停止事件回调，清空过期 `_physics_view`。
>     

> **状态检查**
> 
> - `is_physics_handle_valid() -> bool`  
>     判断物理视图是否已有效创建。
>     
> - `is_valid(indices=None) -> bool`  
>     验证指定或全部 Prim 路径当前是否存在于 USD Stage。
>     

> **批量属性读写**  
> _每组方法接收可选 `indices`，`get_*` 另有 `clone` 参数。编辑模式下操作 USD API，仿真模式下操作张量视图。_

> - **动态摩擦**
>     
>     - `set_dynamic_frictions(values, indices=None) -> None`
>         
>     - `get_dynamic_frictions(indices=None, clone=True) -> Tensor/ndarray`
>         
> - **弹性阻尼**
>     
>     - `set_elasticity_dampings(values, indices=None) -> None`
>         
>     - `get_elasticity_dampings(indices=None, clone=True) -> Tensor/ndarray`
>         
> - **阻尼尺度**
>     
>     - `set_damping_scales(values, indices=None) -> None`
>         
>     - `get_damping_scales(indices=None, clone=True) -> Tensor/ndarray`
>         
> - **泊松比**
>     
>     - `set_poissons_ratios(values, indices=None) -> None`
>         
>     - `get_poissons_ratios(indices=None, clone=True) -> Tensor/ndarray`
>         
> - **杨氏模量**
>     
>     - `set_youngs_moduli(values, indices=None) -> None`
>         
>     - `get_youngs_moduli(indices=None, clone=True) -> Tensor/ndarray`



#### *OmniGlass*
`OmniGlass` 是基于 `VisualMaterial` 的子类，用于在 USD 场景中创建或包装一个 MDL 玻璃材质（`OmniGlass.mdl`），并暴露对“玻璃色”（`glass_color`）、折射率（`glass_ior`）、厚度（`depth`）和“薄壁”属性的便捷读写接口。

---

**初始化参数**:

|参数名|类型|说明|
|---|---|---|
|`prim_path`|`str`|USD场景中材质的路径（如 `/World/GlassMaterial`）。|
|`name`|`str`|材质的自定义名称（默认 `"omni_glass"`）。|
|`shader`|`Optional[UsdShade.Shader]`|可选的现有着色器Prim（若未提供，自动创建或查找）。|
|`color`|`Optional[np.ndarray]`|初始颜色（RGB格式，如 `np.array([0.8, 0.9, 1.0])`）。|
|`ior`|`Optional[float]`|初始折射率（默认无）。|
|`depth`|`Optional[float]`|初始深度值（默认无）。|
|`thin_walled`|`Optional[bool]`|是否启用薄壁模式（默认无）。|

**全部接口**

> **构造与初始化**
> 
> 
```python
OmniGlass(    
	prim_path: str,    
	name: str = "omni_glass",     
	shader: Optional[UsdShade.Shader] = None,     
	color: Optional[np.ndarray] = None,     
	ior: Optional[float] = None,     
	depth: Optional[float] = None,     
	thin_walled: Optional[bool] = None 
)
```

> - **功能**：
>     
>     1. 若已有指定路径的材质 Prim，则直接包装；否则通过 `CreateAndBindMdlMaterialFromLibrary("OmniGlass.mdl")` 创建并移动到目标路径。
>         
>     2. 查找或验证子节点 `shader`，将其作为 MDL Shader 绑定到材质上。
>         
>     3. 根据可选参数 `color`, `ior`, `depth`, `thin_walled`，调用对应 `set_*` 方法初始化属性。
>         
>     4. 最终在材质上创建 `surface` 输出，接入 Shader。
>         

> **属性写入方法**
> 
> - `set_color(color: np.ndarray) -> None`
>     
>     - 在 Shader 上创建或更新 `glass_color` 输入（Color3f）。
>         
> - `set_ior(ior: float) -> None`
>     
>     - 创建或更新**折射率** `glass_ior` 输入（Float）。
>         
> - `set_depth(depth: float) -> None`
>     
>     - 创建或更新**深度（玻璃的视觉厚度）** `depth` 输入（Float）。
>         
> - `set_thin_walled(thin_walled: bool) -> None`
>     
>     - 创建或更新**薄壁模式** (`thin_walled`): 是否启用薄壁效果（用于模拟薄玻璃）
>     - `thin_walled` 输入（Bool）。
>         

> **属性读取方法**
> 
> - `get_color() -> Optional[np.ndarray]`
>     
>     - 返回当前 `glass_color`，如果未设置则打印警告并返回 `None`。
>         
> - `get_ior() -> Optional[float]`
>     
>     - 类似地，读取 `glass_ior`。
>         
> - `get_depth() -> Optional[float]`
>     
>     - 读取 `depth`。
>         
> - `get_thin_walled() -> Optional[bool]`
>     
>     - 读取 `thin_walled`。
>

---
#### *OmniPBR*

`OmniPBR` 是基于 `VisualMaterial` 的子类，用于在 USD 场景中创建或包装一个通用 PBR MDL 材质（`OmniPBR.mdl`），并暴露对常见物理参数和贴图变换的便捷读写接口。

---

##### 关键特性

|英文参数|中文翻译|说明|
|---|---|---|
|`diffuse_color_constant`|基础颜色（漫反射常量）|控制材质的 RGB 漫反射颜色值|
|`diffuse_texture`|漫反射贴图|支持加载外部贴图文件（Asset 路径）|
|`texture_scale`|贴图缩放|UV 缩放比例 `[sx, sy]`|
|`texture_translate`|贴图平移|UV 平移偏移 `[tx, ty]`|
|`reflection_roughness_constant`|反射粗糙度|控制表面反射粗糙程度（范围 0.0–1.0）|
|`metallic_constant`|金属度|控制材质金属性质（范围 0.0–1.0）|
|`project_uvw`|UV 投影开关|启用/禁用自动将贴图投影到物体 UVW 坐标|

- **自动化初始化**：若目标路径不存在 Material 或 Shader Prim，自动创建并绑定 `OmniPBR.mdl`。
    
- **复用能力**：检测并复用场景中已存在的材质或着色器。
    
- **默认值**：初始化时自动设定 `reflection_roughness_constant = 0.5`，`project_uvw = True`。
    
- **错误处理**：调用 `get_*` 时，若对应输入未设置，则打印警告并返回 `None`。
    

---

##### 初始化参数

|参数|类型|说明|
|---|---|---|
|`prim_path`|`str`|USD 场景中材质的路径（如 `/World/Materials/MyPBR`）|
|`name`|`str`|材质实例名称，默认 `"omni_pbr"`|
|`shader`|`Optional[UsdShade.Shader]`|可复用的现有着色器 Prim；未提供时新建一个|
|`texture_path`|`Optional[str]`|初始漫反射贴图文件路径（Asset），如 `"textures/wood.png"`|
|`texture_scale`|`Optional[np.ndarray]`|初始贴图缩放比例，格式 `np.array([sx, sy])`|
|`texture_translate`|`Optional[np.ndarray]`|初始贴图平移偏移，格式 `np.array([tx, ty])`|
|`color`|`Optional[np.ndarray]`|初始基础颜色，RGB 格式 `np.array([r, g, b])`|

---

##### 构造与初始化


```python
OmniPBR(     
		prim_path: str,     
		name: str = "omni_pbr",     
		shader: Optional[UsdShade.Shader] = None,     
		texture_path: Optional[str] = None,     
		texture_scale: Optional[np.ndarray] = None,     
		texture_translate: Optional[np.ndarray] = None,     
		color: Optional[np.ndarray] = None, 
		)
```

1. **包装或新建材质**
    
    - 如果指定路径已有 `UsdShade.Material`，则包装之并打印日志；否则在当前 Stage 上调用 `UsdShade.Material.Define` 新建。
        
2. **查找或创建 Shader**
    
    - 若目标路径下已存在 `shader` 子 Prim，复用之；否则 `UsdShade.Shader.Define` 创建一个新的。
        
    - 调用 `CreateIdAttr("OmniPBR")` 指定 MDL 着色器类型；插入 `out` 输出。
        
3. **创建输入与输出**
    
    - 在 Shader 上批量调用 `CreateInput`：
        
        - `diffuse_color_constant` (Color3f)
            
        - `reflection_roughness_constant` (Float)
            
        - `metallic_constant` (Float)
            
        - `diffuse_texture` (Asset)
            
        - `project_uvw` (Bool)
            
        - `texture_scale` (Float2)
            
        - `texture_translate` (Float2)
            
    - 在 Material 上创建 `surface`、`volume`、`displacement` 输出，并链接到 Shader 的 `out`。
        
    - 设置 Shader 的实现源为外部 Asset `OmniPBR.mdl`。
        
4. **参数初始化**
    
    - 若提供了 `color`、`texture_path`、`texture_scale`、`texture_translate`，依次调用对应的 `set_*` 方法。
        
    - 默认执行 `set_project_uvw(True)` 与 `set_reflection_roughness(0.5)`。
        

---

##### 属性写入方法（Setters）

|方法名|参数|说明|
|---|---|---|
|`set_color(color: np.ndarray) -> None`|`color` (RGB 数组)|设置 `diffuse_color_constant`（漫反射基础颜色）|
|`set_texture(path: str) -> None`|`path` (Asset 路径)|设置 `diffuse_texture`（漫反射贴图文件）|
|`set_texture_scale(x: float, y: float) -> None`|`x, y` (缩放因子)|设置 `texture_scale`（UV 缩放比例）|
|`set_texture_translate(x: float, y: float) -> None`|`x, y` (平移偏移)|设置 `texture_translate`（UV 平移偏移）|
|`set_project_uvw(flag: bool) -> None`|`flag` (布尔)|设置 `project_uvw`（启用/禁用 UV 投影）|
|`set_reflection_roughness(amount: float) -> None`|`amount` (0.0–1.0)|设置 `reflection_roughness_constant`（反射粗糙度）|
|`set_metallic_constant(amount: float) -> None`|`amount` (0.0–1.0)|设置 `metallic_constant`（金属度）|

---

##### 属性读取方法（Getters）

| 方法名                                               | 返回类型                  | 说明                                                  |     |
| ------------------------------------------------- | --------------------- | --------------------------------------------------- | --- |
| `get_color() -> Optional[np.ndarray]`             | `np.ndarray` 或 `None` | 获取 `diffuse_color_constant`，未设置时警告并返回 `None`        |     |
| `get_texture() -> Optional[str]`                  | `str` 或 `None`        | 获取 `diffuse_texture` 路径，未设置时警告并返回 `None`            |     |
| `get_texture_scale() -> Optional[np.ndarray]`     | `np.ndarray` 或 `None` | 获取 `texture_scale`，未设置时警告并返回 `None`                 |     |
| `get_texture_translate() -> Optional[np.ndarray]` | `np.ndarray` 或 `None` | 获取 `texture_translate`，未设置时警告并返回 `None`             |     |
| `get_project_uvw() -> Optional[bool]`             | `bool` 或 `None`       | 获取 `project_uvw` 状态，未设置时警告并返回 `None`                |     |
| `get_reflection_roughness() -> Optional[float]`   | `float` 或 `None`      | 获取 `reflection_roughness_constant`，未设置时警告并返回 `None` |     |
| `get_metallic_constant() -> Optional[float]`      | `float` 或 `None`      | 获取 `metallic_constant`，未设置时警告并返回 `None`             |     |


#### *ParticleMaterial*

`ParticleMaterial` 是对基于位置的动力学（PBD）粒子材质的封装，用于模拟流体、布料和充气体。它统一应用于指定粒子系统下所有关联对象，通过 `ParticleMaterialView` 实现后端张量化读写。

---

##### 关键特性

|英文属性|中文翻译|说明|
|---|---|---|
|`friction`|摩擦系数|粒子与刚体／软体交互的摩擦系数|
|`particle_friction_scale`|粒子摩擦缩放|对固体粒子间摩擦的缩放系数|
|`damping`|速度阻尼|全局速度阻尼系数|
|`viscosity`|黏度|流体粒子的黏度|
|`vorticity_confinement`|涡度约束|为防止数值能量损失，向流体粒子添加涡旋效果|
|`surface_tension`|表面张力|流体粒子的表面张力|
|`cohesion`|内聚力|流体粒子间的内聚力|
|`adhesion`|粘附力|粒子（固体或流体）与刚体／软体的粘附作用|
|`particle_adhesion_scale`|粒子粘附缩放|对固体粒子间粘附的缩放系数|
|`adhesion_offset_scale`|粘附偏移缩放|粘附作用失效的偏移距离相对于静止偏移的比例|
|`gravity_scale`|重力缩放|重力加速度缩放因子，可反向模拟轻质充气体|
|`lift`|升力系数|用于布料/充气体的基本空气动力学升力模型|
|`drag`|阻力系数|用于布料/充气体的基本空气动力学阻力模型|

- **自动创建**：若 `prim_path` 下无 `UsdShade.Material`，自动定义一个新材质。
    
- **后端选择**：优先使用 `SimulationContext` 中的 Torch/NumPy 张量后端。
    
- **单一材质**：每个粒子系统仅支持一个材质实例，应用于所有关联对象。
    
- **警告机制**：输入值超出合理范围或访问未设置属性时打印日志警告。
    

---

##### 初始化参数

|参数|类型|说明|
|---|---|---|
|`prim_path`|`str`|目标 Material Prim 路径（如 `/World/Particles/FluidMat`）|
|`name`|`Optional[str]`|材质实例名称（默认 `"particle_material"`）|
|`friction`|`Optional[float]`|摩擦系数|
|`particle_friction_scale`|`Optional[float]`|粒子摩擦缩放|
|`damping`|`Optional[float]`|速度阻尼|
|`viscosity`|`Optional[float]`|黏度|
|`vorticity_confinement`|`Optional[float]`|涡度约束|
|`surface_tension`|`Optional[float]`|表面张力|
|`cohesion`|`Optional[float]`|内聚力|
|`adhesion`|`Optional[float]`|粘附力|
|`particle_adhesion_scale`|`Optional[float]`|粒子粘附缩放|
|`adhesion_offset_scale`|`Optional[float]`|粘附偏移缩放|
|`gravity_scale`|`Optional[float]`|重力缩放|
|`lift`|`Optional[float]`|升力系数|
|`drag`|`Optional[float]`|阻力系数|

---

##### 构造与初始化

```python
ParticleMaterial(     
				prim_path: str,     
				name: Optional[str] = "particle_material",     
				friction: Optional[float] = None,     
				particle_friction_scale: Optional[float] = None,     
				damping: Optional[float] = None,     
				viscosity: Optional[float] = None,     
				vorticity_confinement: Optional[float] = None,     
				surface_tension: Optional[float] = None,     
				cohesion: Optional[float] = None,     
				adhesion: Optional[float] = None,     
				particle_adhesion_scale: Optional[float] = None,     
				adhesion_offset_scale: Optional[float] = None,     
				gravity_scale: Optional[float] = None,     
				lift: Optional[float] = None,     
				drag: Optional[float] = None, 
				)
```

1. 获取或定义 `UsdShade.Material` Prim，并记录 `_prim_path`、`_prim`、`_material`。
    
2. 选择 `SimulationContext` 后端（Torch/NumPy），并将所有非 `None` 参数转换为张量。
    
3. 调用 `ParticleMaterialView`，传入路径表达式与各参数张量，实现批量物理视图封装。
    

---

##### 生命周期方法

|方法名|返回类型|说明|
|---|---|---|
|`initialize(physics_sim_view=None) -> None`|`None`|初始化底层 `ParticleMaterialView`，创建物理视图|
|`is_valid() -> bool`|`bool`|检查当前 prim 路径在 Stage 中是否存在|
|`post_reset() -> None`|`None`|在仿真重置时恢复到初始状态|

---

##### 属性写入方法（Setters）

|方法名|参数|说明|
|---|---|---|
|`set_friction(value: float) -> None`|`value` (≥0)|设置摩擦系数|
|`set_particle_friction_scale(value: float) -> None`|`value` (≥0)|设置粒子摩擦缩放|
|`set_damping(value: float) -> None`|`value` (≥0)|设置速度阻尼|
|`set_viscosity(value: float) -> None`|`value` (≥0)|设置流体黏度|
|`set_vorticity_confinement(value: float) -> None`|`value` (≥0)|设置涡度约束|
|`set_surface_tension(value: float) -> None`|`value` (≥0)|设置流体表面张力|
|`set_cohesion(value: float) -> None`|`value` (≥0)|设置流体内聚力|
|`set_adhesion(value: float) -> None`|`value` (≥0)|设置粒子与刚体/软体粘附力|
|`set_particle_adhesion_scale(value: float) -> None`|`value` (≥0)|设置固体粒子间粘附缩放|
|`set_adhesion_offset_scale(value: float) -> None`|`value` (≥0)|设置粘附偏移失效比例|
|`set_gravity_scale(value: float) -> None`|`value`|设置重力缩放（可为负值反向重力）|
|`set_lift(value: float) -> None`|`value` (≥0)|设置升力系数|
|`set_drag(value: float) -> None`|`value` (≥0)|设置阻力系数|

---

##### 属性读取方法（Getters）

|方法名|返回类型|说明|
|---|---|---|
|`get_friction() -> float`|`float`|获取当前摩擦系数|
|`get_particle_friction_scale() -> float`|`float`|获取当前粒子摩擦缩放|
|`get_damping() -> float`|`float`|获取当前速度阻尼|
|`get_viscosity() -> float`|`float`|获取当前流体黏度|
|`get_vorticity_confinement() -> float`|`float`|获取当前涡度约束|
|`get_surface_tension() -> float`|`float`|获取当前流体表面张力|
|`get_cohesion() -> float`|`float`|获取当前流体内聚力|
|`get_adhesion() -> float`|`float`|获取当前粒子粘附力|
|`get_particle_adhesion_scale() -> float`|`float`|获取当前固体粒子粘附缩放|
|`get_adhesion_offset_scale() -> float`|`float`|获取当前粘附偏移失效比例|
|`get_gravity_scale() -> float`|`float`|获取当前重力缩放|
|`get_lift() -> float`|`float`|获取当前升力系数|
|`get_drag() -> float`|`float`|获取当前阻力系数|

#### *ParticleMaterialView*

`ParticleMaterialView` 用于在 Isaac Sim 中批量管理基于位置动力学（PBD）的粒子材质属性。它接受一个 Prim 路径正则表达式，封装所有匹配的材质 Prim，并在编辑模式（USD API）与仿真模式（PhysX 张量视图）下，统一读写摩擦、阻尼、黏度、升力等多种物理属性。

---

##### 关键特性

|英文属性|中文翻译|说明|
|---|---|---|
|`frictions`|摩擦系数|粒子与刚体/软体交互的摩擦系数|
|`particle_friction_scales`|粒子摩擦缩放|对固体粒子间摩擦的缩放系数|
|`dampings`|速度阻尼|全局速度阻尼系数|
|`viscosities`|黏度|流体粒子的黏度|
|`vorticity_confinements`|涡度约束|为防止数值能量损失，向流体粒子添加涡旋效应|
|`surface_tensions`|表面张力|流体粒子的表面张力|
|`cohesions`|内聚力|流体粒子间的内聚力|
|`adhesions`|粘附力|粒子（固体或流体）与刚体/软体的粘附作用|
|`particle_adhesion_scales`|粒子粘附缩放|对固体粒子间粘附的缩放系数|
|`adhesion_offset_scales`|粘附偏移缩放|粘附作用失效的偏移距离相对于静止距离的比例|
|`gravity_scales`|重力缩放|重力加速度缩放因子|
|`lifts`|升力系数|布料/充气体的基本空气动力学升力模型|
|`drags`|阻力系数|布料/充气体的基本空气动力学阻力模型|

- **编辑 vs 仿真**：在 Timeline 停止时，通过 USD API 对单个 Prim 属性读写；在仿真运行时，使用 PhysX 张量视图一次性交互全体数据。
    
- **后台切换**：优先使用 `SimulationContext` 的 Torch 张量后端，否则回退到 NumPy。
    
- **正则匹配**：支持用正则表达式批量匹配多个材质 Prim，并统一操作。
    
- **警告与异常**：正则匹配不出 Prim 抛异常；访问未设置属性时打印警告；索引越界或输入非法值亦会记录错误。
    

---

##### 初始化参数

|参数|类型|说明|
|---|---|---|
|`prim_paths_expr`|`str`|匹配材质 Prim 的路径正则表达式（如 `"/World/Particles/.*Material"`）|
|`name`|`str`|视图名称，作为 Scene 的键（默认 `"particle_material_view"`）|
|`frictions`|`Optional[np.ndarray \| torch.Tensor]`|摩擦系数张量，形状 `(N,)`|
|`particle_friction_scales`|`Optional[np.ndarray \| torch.Tensor]`|粒子摩擦缩放张量，形状 `(N,)`|
|`dampings`|`Optional[np.ndarray \| torch.Tensor]`|速度阻尼张量，形状 `(N,)`|
|`viscosities`|`Optional[np.ndarray \| torch.Tensor]`|黏度张量，形状 `(N,)`|
|`vorticity_confinements`|`Optional[np.ndarray \| torch.Tensor]`|涡度约束张量，形状 `(N,)`|
|`surface_tensions`|`Optional[np.ndarray \| torch.Tensor]`|表面张力张量，形状 `(N,)`|
|`cohesions`|`Optional[np.ndarray \| torch.Tensor]`|内聚力张量，形状 `(N,)`|
|`adhesions`|`Optional[np.ndarray \| torch.Tensor]`|粘附力张量，形状 `(N,)`|
|`particle_adhesion_scales`|`Optional[np.ndarray \| torch.Tensor]`|粒子粘附缩放张量，形状 `(N,)`|
|`adhesion_offset_scales`|`Optional[np.ndarray \| torch.Tensor]`|粘附偏移缩放张量，形状 `(N,)`|
|`gravity_scales`|`Optional[np.ndarray \| torch.Tensor]`|重力缩放张量，形状 `(N,)`|
|`lifts`|`Optional[np.ndarray \| torch.Tensor]`|升力系数张量，形状 `(N,)`|
|`drags`|`Optional[np.ndarray \| torch.Tensor]`|阻力系数张量，形状 `(N,)`|

---

##### 构造与初始化

```python
view = ParticleMaterialView(     
							prim_paths_expr: str,     
							name: str = "particle_material_view",     
							frictions: Optional[Tensor] = None,     
							particle_friction_scales: Optional[Tensor] = None, 
							dampings: Optional[Tensor] = None,     
							viscosities: Optional[Tensor] = None,     
							vorticity_confinements: Optional[Tensor] = None,   
							surface_tensions: Optional[Tensor] = None,     
							cohesions: Optional[Tensor] = None,     
							adhesions: Optional[Tensor] = None,     
							particle_adhesion_scales: Optional[Tensor] = None, 
							adhesion_offset_scales: Optional[Tensor] = None,   
							gravity_scales: Optional[Tensor] = None,     
							lifts: Optional[Tensor] = None,     
							drags: Optional[Tensor] = None, 
							)
```

1. **正则匹配**：通过 `find_matching_prim_paths` 找出所有符合 `prim_paths_expr` 的 Prim，并缓存路径与对象；若无匹配则抛出异常。
    
2. **后端与设备**：优先从 `SimulationContext` 获取 Torch 后端与工具，否则加载 NumPy 工具；Device 固定为 `"cpu"`。
    
3. **初始赋值**：对每个非 `None` 参数调用对应的 `set_*` 方法，可在构造时一次性初始化所有属性。
    

---

##### 生命周期方法

|方法名|返回类型|说明|
|---|---|---|
|`initialize(physics_sim_view=None) -> None`|`None`|创建或接收 `SimulationView`，并生成 PhysX 张量视图|
|`is_physics_handle_valid() -> bool`|`bool`|判断物理视图是否已初始化|
|`is_valid(indices=None) -> bool`|`bool`|验证所有（或指定）Prim 路径当前在 Stage 中是否有效|
|`post_reset() -> None`|`None`|在仿真重置时恢复到初始状态（当前空实现）|

---

##### 属性写入方法（Setters）

|方法名|参数|说明|
|---|---|---|
|`set_frictions(values, indices=None)`|`values` `(M,)` 张量|设置摩擦系数；`indices` 指定要操作的 Prim 下标，默认全部|
|`set_particle_friction_scales(values,...)`|同上|设置粒子摩擦缩放|
|`set_dampings(values,...)`|同上|设置速度阻尼|
|`set_viscosities(values,...)`|同上|设置黏度|
|`set_vorticity_confinements(values,...)`|同上|设置涡度约束|
|`set_surface_tensions(values,...)`|同上|设置表面张力|
|`set_cohesions(values,...)`|同上|设置内聚力|
|`set_adhesions(values,...)`|同上|设置粘附力|
|`set_particle_adhesion_scales(values,...)`|同上|设置粒子粘附缩放|
|`set_adhesion_offset_scales(values,...)`|同上|设置粘附偏移缩放|
|`set_gravity_scales(values,...)`|同上|设置重力缩放|
|`set_lifts(values,...)`|同上|设置升力系数|
|`set_drags(values,...)`|同上|设置阻力系数|

---

##### 属性读取方法（Getters）

|方法名|返回类型|说明|
|---|---|---|
|`get_frictions(indices=None, clone=True)`|`Tensor` `(M,)`|获取摩擦系数；`clone=False` 时返回内部缓冲切片|
|`get_particle_friction_scales(...)`|`Tensor` `(M,)`|获取粒子摩擦缩放|
|`get_dampings(...)`|`Tensor` `(M,)`|获取速度阻尼|
|`get_viscosities(...)`|`Tensor` `(M,)`|获取黏度|
|`get_vorticity_confinements(...)`|`Tensor` `(M,)`|获取涡度约束|
|`get_surface_tensions(...)`|`Tensor` `(M,)`|获取表面张力|
|`get_cohesions(...)`|`Tensor` `(M,)`|获取内聚力|
|`get_adhesions(...)`|`Tensor` `(M,)`|获取粘附力|
|`get_particle_adhesion_scales(...)`|`Tensor` `(M,)`|获取粒子粘附缩放|
|`get_adhesion_offset_scales(...)`|`Tensor` `(M,)`|获取粘附偏移缩放|
|`get_gravity_scales(...)`|`Tensor` `(M,)`|获取重力缩放|
|`get_lifts(...)`|`Tensor` `(M,)`|获取升力系数|
|`get_drags(...)`|`Tensor` `(M,)`|获取阻力系数|
#### _PhysicsMaterial_

`PhysicsMaterial` 用于在 Isaac Sim 中对单个物理材质（UsdShade.Material + UsdPhysics.MaterialAPI）进行定义与管理。它接收一个 Prim 路径，自动创建或查询对应的材质 Prim，并通过 MaterialAPI 在编辑与仿真模式下，对静态摩擦、动态摩擦、恢复系数等属性进行读写。

---

##### 关键特性

|英文属性|中文翻译|说明|
|---|---|---|
|`prim_path`|Prim 路径|材质在 USD Stage 中的唯一标识路径|
|`static_friction`|静态摩擦|材质在接触开始时的摩擦系数|
|`dynamic_friction`|动态摩擦|材质在运动过程中持续的摩擦系数|
|`restitution`|恢复系数|材质碰撞后的弹性恢复比例|
|隐式 MaterialAPI|自动应用|自动为 Prim 应用或查询 UsdPhysics.MaterialAPI 接口|
|方法对称性|一致接口|`set_xxx(value)` 与 `get_xxx() -> float?` 读写对称，用法简洁|

---

##### 初始化参数

|参数|类型|说明|
|---|---|---|
|`prim_path`|`str`|要定义或查找的材质 Prim 路径|
|`name`|`str`|材质名称，用于日志或上下文（默认 `"physics_material"`）|
|`static_friction`|`float?`|初始静态摩擦（可选）|
|`dynamic_friction`|`float?`|初始动态摩擦（可选）|
|`restitution`|`float?`|初始恢复系数（可选）|

---

##### 构造与初始化


```python
mat = PhysicsMaterial(     
					prim_path: str,     
					name: str = "physics_material",     
					static_friction: Optional[float] = None,     
					dynamic_friction: Optional[float] = None,     
					restitution: Optional[float] = None 
					)
```

1. **获取 Stage**：调用 `omni.usd.get_context().get_stage()` 拿到当前 USD Stage。
    
2. **定义或查询 Prim**：
    
    - 若路径已存在，包装为 `UsdShade.Material`；
        
    - 否则 `UsdShade.Material.Define` 新建。
        
3. **应用 MaterialAPI**：如该 Prim 尚未有 `UsdPhysics.MaterialAPI`，则 `Apply` 并缓存实例。
    
4. **属性初始化**：针对 `static_friction`、`dynamic_friction`、`restitution`，分别通过 `CreateXxxAttr().Set(value)` 完成初始赋值。
    

---

##### 主要方法（Setters）

|方法|参数|说明|
|---|---|---|
|`set_static_friction(f: float)`|`f`|创建或更新 StaticFrictionAttr 并赋值|
|`set_dynamic_friction(f: float)`|`f`|创建或更新 DynamicFrictionAttr 并赋值|
|`set_restitution(r: float)`|`r`|创建或更新 RestitutionAttr 并赋值|

---

##### 主要方法（Getters）

| 方法                                 | 返回类型           | 说明                                       |
| ---------------------------------- | -------------- | ---------------------------------------- |
| `get_static_friction() -> float?`  | `float`/`None` | 若属性未设置，`log_warn` 并返回 `None`；否则返回当前静态摩擦值 |
| `get_dynamic_friction() -> float?` | `float`/`None` | 同上，针对动态摩擦                                |
| `get_restitution() -> float?`      | `float`/`None` | 同上，针对恢复系数                                |

---

#### _PreviewSurface_
`PreviewSurface` 类专门用于设置物体的 **视觉外观属性**，属于典型的材质系统组件。
`PreviewSurface` 是继承自 `VisualMaterial` 的可视化材质封装，用于在 Isaac Sim 中快速创建和管理基于 `UsdPreviewSurface` 的渲染着色器节点。它接受一个 Prim 路径，自动定义或查询对应的材质与 Shader Prim，并支持颜色、粗糙度、金属度等属性的初始化与读写。

---

##### 关键特性

|英文属性|中文翻译|说明|
|---|---|---|
|`prim_path`|Prim 路径|材质在 USD Stage 中的唯一标识路径|
|`shader`|着色器|可自定义的 `UsdShade.Shader`，默认为 `UsdPreviewSurface`|
|`color`|颜色|材质的漫反射颜色（RGB 三元组）|
|`roughness`|粗糙度|控制表面微观细节对光照的漫反射程度|
|`metallic`|金属度|控制材质金属感（非金属时为 0.0，纯金属时为 1.0）|
|自动连接|Surface 输出|在构造时会将材质的 SurfaceOutput 自动连接到 Shader 的 “surface” 插口|

---

##### 初始化参数

|参数|类型|说明|
|---|---|---|
|`prim_path`|`str`|要定义或查找的 Material Prim 路径|
|`name`|`str`|材质名称，用于日志或上下文（默认 `"preview_surface"`）|
|`shader`|`Optional[UsdShade.Shader]`|预先创建好的 Shader 对象，若为 `None` 则自动在 `${prim_path}/shader` 创建或查询|
|`color`|`Optional[np.ndarray]`|初始漫反射颜色，形状 `(3,)`，值域 [0,1]|
|`roughness`|`Optional[float]`|初始粗糙度属性，值域 [0,1]|
|`metallic`|`Optional[float]`|初始金属度属性，值域 [0,1]|

---

##### 构造与初始化

```python
from pxr import Gf, Sdf, UsdShade
import numpy as np  
surf = PreviewSurface(     
	prim_path: str,     
	name: str = "preview_surface",     
	shader: Optional[UsdShade.Shader] = None,     
	color: Optional[np.ndarray] = None,     
	roughness: Optional[float] = None,     
	metallic: Optional[float] = None 
	)
```

1. **定义或查询 Material Prim**：
    
    - 若 `${prim_path}` 已存在，则包装为 `UsdShade.Material`；否则调用 `UsdShade.Material.Define` 新建。
        
2. **定义或查询 Shader Prim**：
    
    - 在 `${prim_path}/shader` 或 `${prim_path}/Shader` 下查找；若不存在，则调用 `UsdShade.Shader.Define`。
        
3. **父类初始化**：调用 `VisualMaterial.__init__`，将 `prim_path`、`material`、`shader` 列表等传给基类。
    
4. **设置 Shader 类型**：调用 `CreateIdAttr("UsdPreviewSurface")` 指定着色器类型。
    
5. **属性初始化**：
    
    - 若 `color` 不为 `None`，则 `CreateInput("diffuseColor", Float3).Set(Gf.Vec3f(*color))`；
        
    - 若 `roughness` 不为 `None`，则 `CreateInput("roughness", Float).Set(roughness)`；
        
    - 若 `metallic` 不为 `None`，则 `CreateInput("metallic", Float).Set(metallic)`。
        
6. **连接 Surface**：`material.CreateSurfaceOutput().ConnectToSource(shader, "surface")`。
    

---

##### 主要方法（Setters）

|方法|参数|说明|
|---|---|---|
|`set_color(color: np.ndarray)`|`(3,)` 浮点数组|创建或更新 `diffuseColor` 输入并赋值|
|`set_roughness(roughness: float)`|`float`|创建或更新 `roughness` 输入并赋值|
|`set_metallic(metallic: float)`|`float`|创建或更新 `metallic` 输入并赋值|

---

##### 主要方法（Getters）

|方法|返回类型|说明|
|---|---|---|
|`get_color() -> np.ndarray?`|`(3,)` 浮点数组/None|若未设置则 `log_warn` 并返回 `None`，否则返回当前漫反射颜色|
|`get_roughness() -> float?`|`float`/None|若未设置则 `log_warn` 并返回 `None`，否则返回当前粗糙度|
|`get_metallic() -> float?`|`float`/None|若未设置则 `log_warn` 并返回 `None`，否则返回当前金属度|