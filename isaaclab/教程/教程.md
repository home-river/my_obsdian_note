

# 创建空舞台

```python
"""这个脚本演示了如何在 Isaac Sim 中创建一个简单的场景（舞台）。

.. code-block:: bash

    # 使用方法
    ./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py

"""

"""请先启动 Isaac Sim 模拟器。"""

import argparse  # 导入命令行参数解析模块

from isaaclab.app import AppLauncher  # 从 isaaclab.app 中导入 AppLauncher 类

# 创建命令行参数解析器
parser = argparse.ArgumentParser(description="创建空舞台的教程。")
# 将 AppLauncher 的命令行参数添加到解析器中
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
# 获取模拟应用实例
simulation_app = app_launcher.app

"""下面的代码开始主体逻辑。"""

from isaaclab.sim import SimulationCfg, SimulationContext  # 导入模拟配置和上下文类


def main():
    """主函数入口。"""

    # 初始化模拟配置，设置时间步长 dt
    sim_cfg = SimulationCfg(dt=0.01)
    # 创建模拟上下文
    sim = SimulationContext(sim_cfg)
    # 设置主摄像机位置和观察目标
    sim.set_camera_view([2.5, 2.5, 2.5], [0.0, 0.0, 0.0])

    # 重置模拟
    sim.reset()
    # 模拟设置完成提示
    print("[INFO]: 设置完成...")

    # 开始物理模拟循环
    while simulation_app.is_running():
        # 执行一步模拟
        sim.step()


# 如果脚本作为主程序执行，则运行 main 函数并关闭应用
if __name__ == "__main__":
    # 调用主函数
    main()
    # 关闭模拟应用
    simulation_app.close()

```


`SimulationCfg` 的构造函数可以接受多个参数。以下是一些常见的配置参数（具体可参考 Isaac Lab 文档或源码）：

- `dt`：仿真时间步长（秒），即每次 `step()` 前进的模型时间。
    
- `gravity`：重力向量，通常是一个 3 元组或列表，例如 `[0, 0, -9.81]`。
    
- `use_gpu`：布尔值，是否在 GPU 上运行物理仿真。
    
- `up_axis`：场景的上方向，可以是字符串 `"Z"` 或者 `"Y"`，决定重力方向等。
    
- `solver_iterations`：物理求解器迭代次数，影响模拟精度与速度。
    
- `substeps`：每个渲染帧内进行的物理子步数量，用于更精细的物理计算。
    
- `enable_flatcache`：布尔值，是否开启 Omniverse 的扁平缓存加速。
    
- 更多高级选项，如碰撞参数、渲染选项等。
    

示例：

```python
sim_cfg = SimulationCfg(
    dt=0.01,
    gravity=[0.0, 0.0, -9.81],
    use_gpu=True,
    up_axis="Z",
    solver_iterations=10,
    substeps=2
)
```


```python
sim = SimulationContext(sim_cfg)
```

的作用就是根据你传入的配置（`sim_cfg`）初始化并创建一个新的、“空”的模拟环境（舞台）。此时，所有的模拟状态、实体、事件队列等都还没被填充或启动，就像一个刚搭建好的戏台，还没有上演员和道具。后续你可以往这个 `sim` 对象里添加参数、注册实体、推进时间步等操作，都将在这个空白舞台上进行。


---

# 为场景添加基本物体
[生成基本物体到场景中 — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/00_sim/spawn_prims.html)


```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""脚本演示了怎么往stage添加基本物体.

.. code-block:: bash

    # 用法
    ./isaaclab.sh -p scripts/tutorials/00_sim/spawn_prims.py

"""

"""Launch Isaac Sim Simulator first."""

import argparse
from isaaclab.app import AppLauncher

# 创建命令行参数解析器，用于接收脚本运行时的参数
parser = argparse.ArgumentParser(description="Tutorial on spawning prims into the scene.")
# 向解析器添加 Isaac Lab 应用启动器的专用参数（如 --headless, --device 等）
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 根据解析到的 CLI 参数创建并启动 Omniverse Isaac Sim 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取启动后的应用实例

"""后续所有逻辑都在 Isaac Sim 应用中执行"""
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR


def design_scene():
    """在场景中生成地面、光源、基本原语和 USD 模型等对象"""
    # 1. 生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # 调用 config 的 func 方法，将地面 prim 添加到 /World/defaultGroundPlane
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2. 生成远处光源（Distant Light）
    cfg_light_distant = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光源强度
        color=(0.75, 0.75, 0.75),         # 灰白色光
    )
    # 将远处光源放置在世界坐标 (1,0,10)
    cfg_light_distant.func(
        "/World/lightDistant", cfg_light_distant,
        translation=(1, 0, 10)
    )

    # 3. 在 /World/ 下创建一个空的 Xform prim，用作后续所有对象的父节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 4. 生成两个红色实心圆锥
    cfg_cone = sim_utils.ConeCfg(
        radius=0.15,                       # 半径
        height=0.5,                        # 高度
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 0.0, 0.0)  # 红色材质
        ),
    )
    # 将圆锥放置在不同位置
    cfg_cone.func("/World/Objects/Cone1", 
				  cfg_cone,
				  translation=(-1.0, 1.0, 1.0))
    cfg_cone.func("/World/Objects/Cone2", 
			      cfg_cone,
				  translation=(-1.0, -1.0, 1.0))

    # 5. 生成一个带物理属性（刚体）的绿色圆锥
    cfg_cone_rigid = sim_utils.ConeCfg(
        radius=0.15,
        height=0.5,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(),         # 刚体属性
        mass_props=sim_utils.MassPropertiesCfg(mass=1.0),      # 质量属性
        collision_props=sim_utils.CollisionPropertiesCfg(),    # 碰撞属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 1.0, 0.0)  # 绿色材质
        ),
    )
    # 设置位置和旋转四元数
    cfg_cone_rigid.func(
        "/World/Objects/ConeRigid", cfg_cone_rigid,
        translation=(-0.2, 0.0, 2.0),
        orientation=(0.5, 0.0, 0.5, 0.0)
    )

    # 6. 生成一个可变形的蓝色长方体
    cfg_cuboid_deformable = sim_utils.MeshCuboidCfg(
        size=(0.2, 0.5, 0.2),                                  # 尺寸 (X, Y, Z)
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(),  # 可变形物体属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 0.0, 1.0)                      # 蓝色材质
        ),
        physics_material=sim_utils.DeformableBodyMaterialCfg(),  # 可变形材质属性
    )
    cfg_cuboid_deformable.func("/World/Objects/CuboidDeformable", cfg_cuboid_deformable,
                                translation=(0.15, 0.0, 2.0))

    # 7. 加载一个外部 USD 文件（桌子模型）
    cfg = sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Props/Mounts/SeattleLabTable/table_instanceable.usd"
    )
    cfg.func("/World/Objects/Table", cfg, translation=(0.0, 0.0, 1.05))


def main():
    """脚本主入口"""
    # 初始化仿真上下文，设置时间步长 dt=0.01、运行设备（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建新的“空”场景
    # 设置主相机视角：位置 + 目标方向
    sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

    # 调用函数往场景里添加对象
    design_scene()

    # 重置场景，开始仿真前清空内部状态
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 进入仿真循环：只要应用未关闭，就不断执行 sim.step()
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭仿真应用

```

**关键解读**：

---
*1. `GroundPlaneCfg` 可用的参数

`GroundPlaneCfg` 的构造函数通常接收以下可选参数（以 Isaac Lab vX.X API 为准）：

|参数名|类型|说明|默认值|
|---|---|---|---|
|`size`|`tuple[float, float]`|地面平面的 X、Y 方向尺寸|`(10.0, 10.0)`|
|`height`|`float`|地面平面在 Z 轴上的高度|`0.0`|
|`static`|`bool`|是否注册为静态刚体（不参与动力学）|`True`|
|`collision_props`|`CollisionPropertiesCfg`|碰撞属性（摩擦系数、弹性系数等）|`默认值`|
|`visual_material`|`PreviewSurfaceCfg`|可视化材质（漫反射颜色、纹理等）|`默认灰色`|

> **提示**：如果你需要让地面也可变形或带特殊物理属性，可传入相应的 `deformable_props`、`mass_props` 等。

---

*2. 为 USD 模型指定可变形材质

是的，`UsdFileCfg`（以及其它 prim 配置类，比如 `MeshCuboidCfg`、`SphereCfg` 等）都支持接收可变形（deformable）相关的配置：

- **`deformable_props`**：类型为 `DeformableBodyPropertiesCfg`，开启并设置网格变形参数
    
- **`physics_material`**：类型为 `DeformableBodyMaterialCfg`，定义可变形材质的物理特性
    
- **`mass_props`**：类型为 `MassPropertiesCfg`，除了 `mass` 之外，可以指定 `density`
    

---

### 3. 设置密度（Density）或其它物理属性

`MassPropertiesCfg` 除了 `mass`，还接收 `density`。如果同时给出两者，通常以 `mass` 为准；只给 `density` 时，根据模型体积自动计算质量。

其它常见可设置的属性还有：

- 碰撞属性（`CollisionPropertiesCfg`）：`friction`、`restitution`、`collision_group` 等
    
- 刚体属性（`RigidBodyPropertiesCfg`）：`is_kinematic`、`enable_ccd`（连续碰撞检测）等
    
- 可变形属性（`DeformableBodyPropertiesCfg`）：`solver_iterations`、`enable_self_collision` 等

==代码示例：==
```python
import argparse
from isaaclab.app import AppLauncher
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

def design_scene():
    # 在 /World/Objects 下创建根节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 示例 USD 模型路径
    usd_path = f"{ISAAC_NUCLEUS_DIR}/Props/Models/MyModel/my_model.usd"

    # 为 USD 模型配置各种可选属性
    cfg_model = sim_utils.UsdFileCfg(
        # 模型文件路径（必填）
        usd_path=usd_path,

        # —————————————————————————————————————————————————————————————
        # 物理／动力学相关：
        # —————————————————————————————————————————————————————————————

        # 1. 刚体属性（开启刚体模拟，或设置为运动学 kinematic）
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            is_kinematic=False,     # 是否运动学
            enable_ccd=True,        # 连续碰撞检测
            solver_position_iters=4, # 位置求解迭代次数
            solver_velocity_iters=1, # 速度求解迭代次数
        ),

        # 2. 质量属性（直接指定质量，或指定 density 由体积自动算质量）
        mass_props=sim_utils.MassPropertiesCfg(
            mass=2.5,       # 质量，单位 kg
            # density=500.0 # 密度，单位 kg/m³（与 mass 二选一即可）
        ),

        # 3. 碰撞属性（摩擦、弹性、分组等）
        collision_props=sim_utils.CollisionPropertiesCfg(
            friction=0.7,         # 摩擦系数
            restitution=0.2,      # 弹性系数
            collision_group=1,    # 碰撞分组
            collision_filter=0xFF # 过滤掩码
        ),

        # 4. 可变形物体属性（如果想用柔体模拟）
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(
            enable_self_collision=False,
            solver_iterations=15,
            damping_coefficient=0.1,
        ),

        # —————————————————————————————————————————————————————————————
        # 材质／渲染相关：
        # —————————————————————————————————————————————————————————————

        # 5. 预览表面材质（漫反射、镜面、纹理贴图等）
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.8, 0.1, 0.1),
            roughness=0.5,
            metallic=0.0,
            # base_color_texture="Textures/my_diffuse.png"
        ),

        # 6. 可变形体专用物理材质（仅在 deformable_props 有值时生效）
        physics_material=sim_utils.DeformableBodyMaterialCfg(
            youngs_modulus=2e6,
            poissons_ratio=0.35,
            # enable_damping=True,
            # enable_fiber=True
        ),

        # 7. 可选：可视化调试线框
        debug_draw=True,
    )

    # 将配置挂载到场景中的指定路径，并附带 transform
    cfg_model.func(
        "/World/Objects/MyDeformableModel",
        cfg_model,
        translation=(0.0, 0.0, 1.0),
        orientation=(0, 0, 0, 1),
        scale=(1.0, 1.0, 1.0)
    )

def main():
    # 启动 Isaac Lab 应用
    parser = argparse.ArgumentParser()
    AppLauncher.add_app_launcher_args(parser)
    args = parser.parse_args()
    app = AppLauncher(args).app

    # 初始化仿真
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view([2, -2, 2], [0, 0, 1])

    # 设计场景并挂载模型
    design_scene()

    # 重置并开始仿真
    sim.reset()
    while app.is_running():
        sim.step()
    app.close()

if __name__ == "__main__":
    main()

```

---

*4. `.func()` 方法的作用

每个 `*Cfg` 对象（例如 `GroundPlaneCfg`、`ConeCfg`、`UsdFileCfg`）上都有一个 `.func(path, cfg, **kwargs)` 方法，这是一个统一的“挂载”接口，它会：

1. 在场景里 **创建或查找** 指定的 prim（`path`）。
    
2. **应用该配置**（`cfg`）到这个 prim 上，比如设置几何形状、物理属性、材质。
    
3. 接受额外关键字参数，如 `translation=(x,y,z)`、`orientation=(qx,qy,qz,qw)`、`scale=(sx,sy,sz)` 等，用于直接指定 transform。

---


# 深入了解AppLauncher

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
这个脚本演示了如何通过 AppLauncher 启动并运行 Isaac Sim

.. code-block:: bash

    # 用法示例
    ./isaaclab.sh -p scripts/tutorials/00_sim/launch_app.py

"""

"""请先启动 Isaac Sim Simulator 后，再运行此脚本"""

import argparse
from isaaclab.app import AppLauncher

# ===== 1. 创建命令行参数解析器，用于接收脚本启动参数 =====
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
# 自定义参数：长方体边长
parser.add_argument(
    "--size", type=float, default=1.0,
    help="Side-length of cuboid"
)
# 自定义参数：视口及截图宽度
parser.add_argument(
    "--width", type=int, default=1280,
    help="Width of the viewport and generated images. Defaults to 1280"
)
# 自定义参数：视口及截图高度
parser.add_argument(
    "--height", type=int, default=720,
    help="Height of the viewport and generated images. Defaults to 720"
)

# ===== 2. 将 AppLauncher 自带的命令行参数（如 --headless, --device）添加进来 =====
AppLauncher.add_app_launcher_args(parser)
# 解析所有命令行参数
args_cli = parser.parse_args()

# ===== 3. 使用解析好的参数创建并启动 Omniverse Isaac Sim 应用 =====
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取 SimulationApp 实例

"""下面开始核心仿真逻辑"""
import isaaclab.sim as sim_utils

def design_scene():
    """设计场景：添加地面、光源和长方体"""
    # 1) GroundPlaneCfg：生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # func() 创建 prim 并应用配置
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2) DistantLightCfg：生成远处光源
    cfg_light = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光照强度
        color=(0.75, 0.75, 0.75),         # 灰白色
    )
    cfg_light.func(
        "/World/lightDistant", cfg_light,
        translation=(1, 0, 10)            # 放置在 (1,0,10)
    )

    # 3) CuboidCfg：生成长方体
    cfg_cuboid = sim_utils.CuboidCfg(
        size=[args_cli.size] * 3,         # XYZ 三维方向尺寸均为 --size
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 1.0, 1.0)  # 白色材质
        ),
    )
    # 将长方体放置到合适高度 (size/2)
    cfg_cuboid.func(
        "/World/Object", cfg_cuboid,
        translation=(0.0, 0.0, args_cli.size / 2)
    )


def main():
    """脚本主程序入口"""
    # 4) 初始化仿真上下文：时间步 dt=0.01，运行设备由 --device 决定
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建空场景

    # 5) 设置主相机视角：位置与朝向
    sim.set_camera_view([
        2.0, 0.0, 2.5    # 相机位置 (X,Y,Z)
    ], [
        -0.5, 0.0, 0.5   # 相机朝向向量
    ])

    # 6) 设计并填充场景
    design_scene()

    # 7) 重置仿真：清空内部状态并开始运行
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 8) 循环执行仿真步
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭 Isaac Sim 应用

```


---

### 1. 接入并解析自定义与 AppLauncher 参数

```python
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
parser.add_argument("--size", type=float, default=1.0, help="Side-length of cuboid")
parser.add_argument("--width", type=int, default=1280, help="Width of the viewport …")
parser.add_argument("--height", type=int, default=720, help="Height of the viewport …")

# 将 AppLauncher 本身所需的参数（如 --headless, --device, --renderer 等）注入到同一解析器中
AppLauncher.add_app_launcher_args(parser)
args_cli = parser.parse_args()
```

- **目的**：把你自己脚本的参数（`--size`, `--width`, `--height`）和 `AppLauncher` 所依赖的底层渲染/仿真参数合并在一起，用同一个命令行接口一次性传递给脚本。
    
- **好处**：无需区分两套参数，启动时只需一行命令即可同时控制应用层和仿真层的行为。
    

---

### 2. 通过 `AppLauncher` 启动 Isaac Sim

```python
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app
```

- **`AppLauncher(args_cli)`**：内部会根据命令行参数启动 Omniverse Kit 应用，加载 Isaac Sim 模块，并返回一个封装好的 `Application` 对象。
    
- **`app_launcher.app`**：这是对底层 `SimulationApp` 的引用，用于之后查询“应用是否还在运行”、关闭应用等操作。
    

---

### 3. 设计场景逻辑与 `.func()` 用法

```python
def design_scene():
    cfg_ground = sim_utils.GroundPlaneCfg()
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    cfg_light = sim_utils.DistantLightCfg(intensity=3000.0, color=(0.75,0.75,0.75))
    cfg_light.func("/World/lightDistant", cfg_light, translation=(1,0,10))

    cfg_cuboid = sim_utils.CuboidCfg(size=[args_cli.size]*3, visual_material=...)
    cfg_cuboid.func("/World/Object", cfg_cuboid, translation=(0,0,args_cli.size/2))
```

- **各 `*Cfg` 类**：负责持有一系列参数（几何、物理、材质等）。
    
- **`.func(path, cfg, **kwargs)`**：统一接口，用于
    
    1. 在 USD 场景中创建（或定位）指定路径下的 prim；
        
    2. 将 `cfg` 中的所有配置应用到该 prim；
        
    3. 额外接收 `translation`、`orientation`、`scale` 等 transform 参数。
        

---

### 4. 仿真上下文初始化与主循环

```python
sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
sim = sim_utils.SimulationContext(sim_cfg)
sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

design_scene()
sim.reset()
while simulation_app.is_running():
    sim.step()
```

- **`SimulationCfg`**：封装了物理仿真的全局设置（时间步长、执行设备等）。
    
- **`SimulationContext`**：在内部构建和管理物理世界状态、时钟、渲染循环。
    
- **`sim.set_camera_view(pos, target)`**：一次性设置相机位置与朝向。
    
- **`sim.reset()`**：启动前重置场景，确保所有 prim、物理状态回到初始。
    
- **循环调用 `sim.step()`**：在每帧里推进一次物理与渲染。
    

---

#### 小结

- **核心就在于**：用 `AppLauncher` 统一管理底层应用的启动和参数，再通过 `sim_utils` 的高阶配置类和 `.func()` 方法快速构建场景，最后在 `SimulationContext` 中集中驱动仿真循环。
    
- 这种分层结构让“启动”、“配置场景”、“运行仿真”三者职责明确，代码既灵活又易于维护。




----

# 将新机器人添加到 Isaac Lab
[将新机器人添加到 Isaac Lab — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/01_assets/add_new_robot.html)

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import argparse
from isaaclab.app import AppLauncher
import numpy as np
import torch
import isaaclab.sim as sim_utils
# 导入 ImplicitActuatorCfg：用于创建显式阻抗执行器，控制关节弹性和阻尼特性
from isaaclab.actuators import ImplicitActuatorCfg
# 资产基础配置，用于定义地面、灯光、机器人等
from isaaclab.assets import AssetBaseCfg
# ArticulationCfg：用于定义可动关节及其物理属性
from isaaclab.assets.articulation import ArticulationCfg
# 交互式场景及其配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg
# Isaac Nucleus 资源路径常量，用于加载 USD 模型
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

# ===== 1. 命令行参数配置 =====
# 创建 ArgumentParser 实例用于解析脚本运行时的参数
parser = argparse.ArgumentParser(
    description="此脚本演示如何在 Isaac Lab 环境中添加自定义机器人。"
)
# 用户可指定并行仿真环境数量，默认为 1
parser.add_argument(
    "--num_envs", type=int, default=1,
    help="要创建的并行仿真环境数量。"
)
# 将 AppLauncher 支持的标准参数（如 --headless, --device）加入解析器
AppLauncher.add_app_launcher_args(parser)
# 解析命令行输入，得到 args_cli 对象
args_cli = parser.parse_args()

# ===== 2. 启动 Omniverse Isaac Sim 应用 =====
# 通过 AppLauncher 根据解析参数启动 SimulationApp
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取底层 SimulationApp 实例

# ===== 3. 定义两个自定义机器人配置：JETBOT 和 DOFBOT =====
# 3.1 Jetbot：简单驱动机器人，所有关节使用阻抗执行器
JETBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Jetbot/jetbot.usd"
    ),
    actuators={
        # 针对名称匹配正则 ".*" 的所有关节，使用默认阻尼和刚度
        "wheel_acts": ImplicitActuatorCfg(
            joint_names_expr=[".*"],  # 匹配所有关节名称
            damping=None,               # None 表示使用物理默认阻尼
            stiffness=None              # None 表示使用物理默认刚度
        )
    },
)

# 3.2 Dofbot：6-DOF 机械臂，细化物理属性、自碰撞和执行器参数
DOFBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Dofbot/dofbot.usd",
        # 定义刚体属性：是否受重力影响和最大分离速度
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            max_depenetration_velocity=5.0,
        ),
        # 定义关节根节点属性：开启自碰撞及迭代求解次数
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=True,
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=0
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        # 初始关节角位置（rad）
        joint_pos={
            "joint1": 0.0,
            "joint2": 0.0,
            "joint3": 0.0,
            "joint4": 0.0,
        },
        # 机器人整体初始位置偏移（x,y,z）
        pos=(0.25, -0.25, 0.0),
    ),
    actuators={
        # 前两个关节阻抗执行器，可设置力矩和速度限制
        "front_joints": ImplicitActuatorCfg(
            joint_names_expr=["joint[1-2]"],
            effort_limit_sim=100.0,    # 最大扭矩 (Nm)
            velocity_limit_sim=100.0,  # 最大速度 (rad/s)
            stiffness=10000.0,         # 刚度 (N·m/rad)
            damping=100.0,             # 阻尼 (N·m·s/rad)
        ),
        # 独立配置 joint3 和 joint4
        "joint3_act": ImplicitActuatorCfg(
            joint_names_expr=["joint3"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
        "joint4_act": ImplicitActuatorCfg(
            joint_names_expr=["joint4"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
    },
)

# ===== 4. 自定义交互式场景配置 =====
class NewRobotsSceneCfg(InteractiveSceneCfg):
    """场景配置：包含地面、全景光照和机器人实例。"""
    # 地面平面，作为机器人行走参考
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",
        spawn=sim_utils.GroundPlaneCfg()
    )
    # 全景半球光，用于模拟环境光照
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,          # 光照强度
            color=(0.75, 0.75, 0.75)     # 灯光颜色 (RGB)
        )
    )
    # 将机器人配置绑定到命名空间，支持多环境实例化
    Jetbot = JETBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Jetbot")
    Dofbot = DOFBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Dofbot")

# ===== 5. 仿真主循环逻辑 =====
def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """执行仿真步进、机器人控制和周期性重置。"""
    # 获取物理仿真步长 (秒)
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0  # 累计仿真时间
    count = 0       # 计步器，用于定时动作切换和重置

    # 当窗口未关闭时持续运行
    while simulation_app.is_running():
        # 每隔 500 步重置机器人到初始状态
        if count % 500 == 0:
            count = 0
            # 克隆默认根部状态，并根据环境原点偏移
            root_jetbot = scene["Jetbot"].data.default_root_state.clone()
            root_jetbot[:, :3] += scene.env_origins
            root_dofbot = scene["Dofbot"].data.default_root_state.clone()
            root_dofbot[:, :3] += scene.env_origins

            # 将位置、姿态和速度写回仿真
            scene["Jetbot"].write_root_pose_to_sim(root_jetbot[:, :7])
            scene["Jetbot"].write_root_velocity_to_sim(root_jetbot[:, 7:])
            scene["Dofbot"].write_root_pose_to_sim(root_dofbot[:, :7])
            scene["Dofbot"].write_root_velocity_to_sim(root_dofbot[:, 7:])

            # 重置关节位置和速度
            jp, jv = (
                scene["Jetbot"].data.default_joint_pos.clone(),
                scene["Jetbot"].data.default_joint_vel.clone(),
            )
            scene["Jetbot"].write_joint_state_to_sim(jp, jv)
            jp, jv = (
                scene["Dofbot"].data.default_joint_pos.clone(),
                scene["Dofbot"].data.default_joint_vel.clone(),
            )
            scene["Dofbot"].write_joint_state_to_sim(jp, jv)

            scene.reset()  # 场景全局重置，多环境同时作用
            print("[INFO]: 重置 Jetbot 和 Dofbot 状态...")

        # ===== 机器人控制逻辑 =====
        # Jetbot: 直行与转向交替，每 100 步内前 75 步直行，后 25 步转弯
        if count % 100 < 75:
            action = torch.Tensor([[10.0, 10.0]])  # 左右轮相同速率，直行
        else:
            action = torch.Tensor([[5.0, -5.0]])   # 反向差速，原地转动
        scene["Jetbot"].set_joint_velocity_target(action)

        # Dofbot: 四个关节做正弦波振动，幅度 0.25 rad，频率 0.5 Hz
        wave_action = scene["Dofbot"].data.default_joint_pos
        wave_action[:, 0:4] = 0.25 * np.sin(2 * np.pi * 0.5 * sim_time)
        scene["Dofbot"].set_joint_position_target(wave_action)

        # 写入所有命令并推进仿真一步
        scene.write_data_to_sim()
        sim.step()
        sim_time += sim_dt
        count += 1
        # 更新场景渲染和交互
        scene.update(sim_dt)

# ===== 6. 程序入口 =====
def main():
    """脚本入口：初始化仿真上下文和场景，并启动循环。"""
    # 构造仿真配置，包括设备类型（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)

    # 可选：设置默认摄像机视角 (位置, 朝向)
    sim.set_camera_view([3.5, 0.0, 3.2], [0.0, 0.0, 0.5])

    # 构建场景配置，指定环境数量和间距
    scene_cfg = NewRobotsSceneCfg(args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)

    sim.reset()  # 初始化仿真状态
    print("[INFO]: 设置完成，开始运行仿真...")
    run_simulator(sim, scene)

if __name__ == "__main__":
    main()
    # 退出时关闭应用窗口，释放资源
    simulation_app.close()

```

==关键解读==：

## 1. ImplicitActuatorCfg vs ArticulationCfg

- **ArticulationCfg**  
    这是对“树状关节（Articulation）”整体的配置，通常包括：
    
    - 铰链／关节数量与拓扑
        
    - 各关节的物理属性（质量、惯量、摩擦、初始位置等）
        
    - 刚体之间的连接方式（铰链、滑动、球铰）
        
    - 关节限制（转动角度／线性位移范围）
        
    - 动力学求解器参数（比如 solver iteration count）  
        简言之，`ArticulationCfg` 定义了一个多关节机器人或机械臂的物理骨架与动力学属性。
        
- **ImplicitActuatorCfg**  
    这是针对“隐式执行器（Implicit Actuator）”的配置。隐式执行器通常指在动力学求解过程中，将执行器力（torque/force）以“隐式积分”方式加入求解器，以提升数值稳定性。它包含：
    
    - 执行器类型（位置控制、力控制、阻抗控制等）
        
    - 控制参数（刚度 `stiffness`、阻尼 `damping`、最大力矩等）
        
    - 目标命令格式（位置目标、速度目标或力目标）  
        简单说，`ImplicitActuatorCfg` 定义了如何把高层控制命令转换为关节／驱动力，并以隐式方式与物理引擎耦合。
        

---

## 2. 阻抗执行器（Impedance Actuator）是什么？

阻抗控制（Impedance Control）是一种把机器人关节或末端执行器当作弹簧-阻尼系统来控制的方法。与“纯位置控制”不同，阻抗执行器会根据：

- 目标位置偏差 → 产生弹性力（`F = K (x_target − x_actual)`）
    
- 速度差异 → 产生阻尼力（`F = D (v_target − v_actual)`）  
    这样，当执行器和环境发生接触时，它能以更自然的“软”响应来吸收冲击，增强交互安全性与稳定性。
    

在隐式执行器中，阻抗模型的力直接融入物理求解器矩阵，允许大步长且更稳定地模拟高刚度情形。

---

## 3. 将机器人绑定到实例空间（instance space）是什么意思？

在多场景或多并发仿真中，“实例空间”指一组“相同模型”的并行副本。

- 你把一个机器人模型（URDF／USD）实例化多份，每份称为一个“实例”。
    
- “绑定到实例空间”即把这具机器人物理骨架、状态跟踪、碰撞体等关联到某个实例 ID，使后续的状态更新、碰撞检测、渲染等，都在这个命名空间里并行进行。
    
- 这样你就可以一次性批量加载 N 个机器人，利用 GPU 并行加速物理与感知。
    

---

## 4. `def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):` 这里是什么？

这里是一个函数定义，接收两个参数：

- `sim: sim_utils.SimulationContext`：封装物理引擎、时间步长、步进函数等。
    
- `scene: InteractiveScene`：封装场景资源、渲染相机、交互事件等。
    

它是你的控制脚本里向引擎传入“仿真上下文”与“场景对象”，然后在函数内部启动主循环。

---

## 5. `root_jetbot = scene["Jetbot"].data.default_root_state.clone()` 是做什么用的？

- `scene["Jetbot"]`：通过名字从场景中取到名为 “Jetbot” 的实体（Instance）。
    
- `.data.default_root_state`：这是这具机器人的“默认根状态”（一般包括全局位置、朝向、各关节初始角度）。
    
- `.clone()`：复制一份这个状态副本，避免直接修改原始模板。
    

**用途**：拿到该机器人从零加载时的基准状态，之后可以在仿真开始前或复位时，直接把它设回这份克隆状态。

---

# 与刚性物体交互

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
本脚本演示如何在 Isaac Sim 中创建一个刚性物体并与之交互。

使用方法：
    ./isaaclab.sh -p scripts/tutorials/01_assets/run_rigid_object.py
"""

"""启动 Isaac Sim 仿真器后，再执行本脚本。"""

import argparse
from isaaclab.app import AppLauncher

# —— 命令行参数配置 —— #
# 创建参数解析器，描述本教程用途
parser = argparse.ArgumentParser(
    description="Tutorial on spawning and interacting with a rigid object."
)
# 添加 Isaac Lab 通用启动器参数（如设备、GUI 开关等）
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# —— 启动仿真应用 —— #
# 使用解析出的参数创建并启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 返回已启动的仿真应用句柄

"""之后的内容均在仿真环境启动后执行。"""

import torch
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
import isaaclab.utils.math as math_utils
from isaaclab.assets import RigidObject, RigidObjectCfg
from isaaclab.sim import SimulationContext


def design_scene():
    """设计场景：包含地面、光源、坐标原点组及刚性物体。"""
    # 1. 地面平面配置
    cfg = sim_utils.GroundPlaneCfg()
    # 将地面添加至场景根路径
    cfg.func("/World/defaultGroundPlane", cfg)

    # 2. 场景环境光
    cfg = sim_utils.DomeLightCfg(
        intensity=2000.0,  # 灯光强度
        color=(0.8, 0.8, 0.8)  # 灯光颜色（RGB）
    )
    cfg.func("/World/Light", cfg)

    # 3. 创建设定的多个坐标原点，用于多实例场景测试
    origins = [
        [0.25, 0.25, 0.0],
        [-0.25, 0.25, 0.0],
        [0.25, -0.25, 0.0],
        [-0.25, -0.25, 0.0],
    ]
    for i, origin in enumerate(origins):
        # 在 /World 下依次创建 Origin0, Origin1... 的 Xform 节点
        prim_utils.create_prim(
            f"/World/Origin{i}", "Xform", translation=origin
        )

    # 4. 刚性物体配置：生成多个绿色圆锥体的刚性配置
    cone_cfg = RigidObjectCfg(
        prim_path="/World/Origin.*/Cone",  # USD 路径支持正则匹配
        spawn=sim_utils.ConeCfg(
            radius=0.1,  # 圆锥半径
            height=0.2,  # 圆锥高度
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),  # 刚体物理属性
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),  # 质量属性
            collision_props=sim_utils.CollisionPropertiesCfg(),  # 碰撞属性
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0),  # 绿色
                metallic=0.2  # 金属感
            ),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(),  # 初始状态配置
    )
    # 实例化 RigidObject，负责管理物体生命周期与接口
    cone_object = RigidObject(cfg=cone_cfg)

    # 返回场景实体与原点列表，用于后续仿真
    scene_entities = {"cone": cone_object}
    return scene_entities, origins


def run_simulator(
    sim: sim_utils.SimulationContext,
    entities: dict[str, RigidObject],
    origins: torch.Tensor,
):
    """仿真主循环：包括重置、物理步进、状态更新与打印。"""
    # 从实体字典中提取刚性物体对象
    cone_object = entities["cone"]
    # 物理步长与计时器初始化
    sim_dt = sim.get_physics_dt()  # 从仿真上下文获取 dt
    sim_time = 0.0  # 模拟时间
    count = 0  # 步骤计数

    # 主循环：当仿真应用窗口未关闭时持续执行
    while simulation_app.is_running():
        # —— 重置逻辑：每250步重置一次（例如用于随机化初始位置） —— #
        if count % 250 == 0:
            sim_time = 0.0  # 重置模拟时间
            count = 0  # 重置步数计数
            # 1) 恢复默认根状态
            root_state = cone_object.data.default_root_state.clone()
            # 2) 叠加环境原点偏移
            root_state[:, :3] += origins
            # 3) 在圆柱体区域内随机采样位置，增加随机性
            root_state[:, :3] += math_utils.sample_cylinder(
                radius=0.1,
                h_range=(0.25, 0.5),
                size=cone_object.num_instances,
                device=cone_object.device,
            )
            # 4) 写入仿真：位置 + 朝向（前7维）
            cone_object.write_root_pose_to_sim(root_state[:, :7])
            # 5) 写入仿真：线速度 + 角速度（后6维）
            cone_object.write_root_velocity_to_sim(root_state[:, 7:])
            # 完成数据写入后调用 reset 清理内部缓冲
            cone_object.reset()
            print("----------------------------------------")
            print("[INFO]: Resetting object state...")

        # —— 将脚本中管理的数据写入仿真 —— #
        cone_object.write_data_to_sim()
        # —— 推进物理一步 —— #
        sim.step()
        # —— 更新时间与步数 —— #
        sim_time += sim_dt
        count += 1
        # —— 从仿真中拉取最新状态到脚本缓冲 —— #
        cone_object.update(sim_dt)
        # 每50步打印当前根位置，观察运动轨迹
        if count % 50 == 0:
            pos = cone_object.data.root_state_w[:, :3]
            print(f"Root position (in world): {pos}")


def main():
    """入口函数：初始化仿真、设计场景并启动主循环。"""
    # 1) 创建仿真配置并上下文
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = SimulationContext(sim_cfg)
    # 2) 设置主相机视角，便于观察场景
    sim.set_camera_view(
        eye=[1.5, 0.0, 1.0],  # 相机位置
        target=[0.0, 0.0, 0.0],  # 相机目标点
    )
    # 3) 设计场景：地面、光源、原点组与刚性物体
    scene_entities, scene_origins = design_scene()
    # 转为张量并移动到正确设备
    scene_origins = torch.tensor(scene_origins, device=sim.device)
    # 4) 重置仿真，加载所有 USD 资源和配置
    sim.reset()
    print("[INFO]: Setup complete...")
    # 5) 进入仿真主循环
    run_simulator(sim, scene_entities, scene_origins)


# 脚本入口检测
if __name__ == "__main__":
    main()
    # 当主循环结束（如窗口关闭）后，关闭仿真应用
    simulation_app.close()

```


==解读：==


### 1. `CollisionPropertiesCfg` 可配置的参数

`sim_utils.CollisionPropertiesCfg` 用于控制刚体的碰撞行为，你可以通过它来精细调节物理引擎中碰撞检测和接触力学的属性。常见可选参数（以关键字方式传入）包括：

|参数名|含义|类型／默认值|
|---|---|---|
|`restitution`|反弹系数，决定碰撞后物体的回弹程度，范围 0,10,1|`float`, 默认约 `0.0`|
|`static_friction`|静摩擦系数，在接触初始阶段抗滑动的能力|`float`, 默认约 `0.5`|
|`dynamic_friction`|动摩擦系数，物体相对滑动时的摩擦大小|`float`, 默认约 `0.5`|
|`friction_direction`|自定义摩擦方向（用于各向异性摩擦），通常留空使用默认|`Tuple[float, float, float]`|
|`contact_offset`|“近场接触”检测距离阈值，小于该距离即认为发生接触|`float`, 默认约 `0.01` m|
|`rest_offset`|“稳定接触”阈值，低于此距离物体会被视作已稳定接触|`float`, 默认约 `0.0` m|
|`enable_ccd`|是否开启连续碰撞检测（Continuous Collision Detection）|`bool`, 默认 `False`|
|`ccd_thickness`|若开启 CCD，此厚度决定能检测到的最小穿透厚度|`float`, 默认约 `0.01` m|
|`solver_position_iteration_count`|碰撞求解器在位置修正时的迭代次数|`int`, 默认约 `4`|
|`solver_velocity_iteration_count`|碰撞求解器在速度修正时的迭代次数|`int`, 默认约 `1`|

> **示例**
> 
> ```python
> collision_props = sim_utils.CollisionPropertiesCfg(
>     restitution=0.1,
>     static_friction=0.6,
>     dynamic_friction=0.4,
>     contact_offset=0.02,
>     enable_ccd=True,
>     ccd_thickness=0.005
> )
> ```

---

### 2. `init_state=RigidObjectCfg.InitialStateCfg()` 的作用

`InitialStateCfg` 是用来指定刚体在「首次生成」或「场景重置」时的初始状态（位姿／速度）配置类。通常它包含：

- **位置与朝向**（Position & Orientation）  
    可以自行传入一个固定的 `pose`，或者使用默认的 USD 路径里定义的初始位姿。
    
- **线速度与角速度**（Linear & Angular Velocity）  
    若你希望物体一生成就携带一定初速度，例如抛射体，就可以在这里设置。
    
- **随机化选项**  
    有些扩展版本支持在初始状态上加噪声或随机化（例如 `pos_range`, `ori_range`），用于批量场景随机测试。
    

如果你不传任何参数（如示例中的空调用），它会使用 USD 文件里定义的「默认根状态」和「默认速度」作为物体的初始状态。

---

### 3. 为什么要 `cone_object = RigidObject(cfg=cone_cfg)` 实例化？

把配置（`RigidObjectCfg`）“落实”到仿真中，需要创建一个**对象实例**来管理它的全生命周期和接口：

1. **资源加载**
    
    - 实例化时，内部会根据 `cfg.prim_path`、`spawn` 设定真正往 USD 场景里生成对应的几何体、物理体、碰撞体与材质。
        
2. **数据缓冲**
    
    - 生成后会分配一系列缓冲区（root_state、joint_state、接触信息等），用于在脚本和仿真引擎之间高效同步。
        
3. **API 接口**
    
    - 实例对象提供 `write_root_pose_to_sim`、`write_data_to_sim`、`reset`、`update` 等方法，让你可以在仿真主循环里很方便地：
        
        - 写入新的位姿／速度
            
        - 推送关节／状态更新
            
        - 拉取反馈信息（如最新的世界坐标、接触力）
            
        - 一键复位到初始状态
            
4. **多实例管理**
    
    - 如果你在同一个场景里需要多个相同配置的物体，只需多次实例化同一个配置，它们就会自动在不同的 `prim_path`（比如用正则 `/World/Origin.*/Cone`）下同步生成并分开管理。
        

简而言之，**配置只是“蓝图”，而实例化才是真正把物体“搭”到仿真世界里，并赋予它可操作的接口与数据通道**。没有实例化，你就没有后续写状态、读状态、调用物理步等一切操作的句柄。


---
