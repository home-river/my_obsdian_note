
# Task Design Workflows（任务设计工作流程）

以下类是 Cartpole 环境配置类的一部分。 `RewardsCfg` 类定义了构成奖励函数的各个项。每个奖励项由其函数实现、权重和要传递给函数的附加参数定义。用户可以定义多个奖励项及其权重，以用于奖励函数。

```python
@configclass
class RewardsCfg:
    """MDP 的奖励配置类，定义多项奖励/惩罚条目。"""

    # (1) 存活奖励：只要 agent 处于存活状态，每步获得 +1.0
    alive = RewTerm(
        func=mdp.is_alive,   # 判定是否存活，返回 1 或 0
        weight=1.0           # 权重 +1.0
    )

    # (2) 终止惩罚：一旦进入终止/失败状态，给予 -2.0 惩罚
    terminating = RewTerm(
        func=mdp.is_terminated,  # 判定是否终止，返回 1 或 0
        weight=-2.0              # 权重 -2.0
    )

    # (3) 主任务：保持杆子直立
    pole_pos = RewTerm(
        func=mdp.joint_pos_target_l2,  # 计算关节位置与目标的 L2 距离
        weight=-1.0,                   # 距离越大，惩罚越多
        params={
            # 指定场景实体及关节名称
            "asset_cfg": SceneEntityCfg(
                "robot",
                joint_names=["cart_to_pole"]  # 小车-杆子连接处转轴
            ),
            "target": 0.0  # 目标位置（0 弧度，完全垂直）
        },
    )

    # (4) 形状奖励：减小小车速度以平滑运动
    cart_vel = RewTerm(
        func=mdp.joint_vel_l1,  # 计算关节速度的 L1 范数（绝对值和）
        weight=-0.01,          # 权重较小，次要惩罚
        params={
            "asset_cfg": SceneEntityCfg(
                "robot",
                joint_names=["slider_to_cart"]  # 滑轨到小车的移动关节
            )
        },
    )

    # (5) 形状奖励：减缓杆子摆动速度
    pole_vel = RewTerm(
        func=mdp.joint_vel_l1,  # 同样使用 L1 速度惩罚
        weight=-0.005,         # 权重更小，辅助作用
        params={
            "asset_cfg": SceneEntityCfg(
                "robot",
                joint_names=["cart_to_pole"]  # 杆子旋转关节
            )
        },
    )

```

解读：

```python
@configclass
class RewardsCfg:
    """Reward terms for the MDP."""
```

- `@configclass`  
    这是一个装饰器，用来标记这是一个“配置类”（configuration class）。通常配合某个配置系统使用，能够自动地把类里的属性当作可调参数加载或保存。
    
- `class RewardsCfg:`  
    定义了一个奖励配置类 `RewardsCfg`，用于描述在这个马尔可夫决策过程（MDP）里，各种奖励项（reward term）应该如何计算和加权。
    

---

***(1) Constant running reward

```python
alive = RewTerm(func=mdp.is_alive, weight=1.0)
```

- **`alive`**：名称
    
- **`RewTerm`**：表示一个奖励项（Reward Term）的构造器
    
    - `func=mdp.is_alive`：调用环境（MDP）接口 `is_alive(state)`，如果“还存活”（未失败）则返回 1，否则为 0
        
    - `weight=1.0`：这个项的权重为 +1.0
        
- **作用**：只要保持存活，就持续获得 +1 的奖励，鼓励 agent 尽量长时间不触发终止条件。
    

---

 ***(2) Failure penalty

```python
terminating = RewTerm(func=mdp.is_terminated, weight=-2.0)
```

- **`terminating`**：名称
    
- `func=mdp.is_terminated`：调用环境接口 `is_terminated(state)`，若进入失败/终止状态返回 1，否则 0
    
- `weight=-2.0`：权重 -2
    
- **作用**：一旦失败（如倒立摆倒下、越界等），立即付出 -2 的惩罚，降低 agent 盲目追求生存时忽略主要目标的可能性。
    

---

***(3) Primary task: keep pole upright

```python
pole_pos = RewTerm(
    func=mdp.joint_pos_target_l2,
    weight=-1.0,
    params={
        "asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"]),
        "target": 0.0
    },
)
```

- **`pole_pos`**：名称
    
- `func=mdp.joint_pos_target_l2`：计算某一关节当前位置与指定目标位置的 L2（欧氏）距离（或平方距离）
    
- `weight=-1.0`：前面有负号，表示距离越大，惩罚越多
    
- `params`：额外参数
    
    - `"asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"])`  
        指定要测量的关节属于哪个实体——这里是“robot” 中名为 `cart_to_pole` 的关节（即小车和杆子的转动轴）
        
    - `"target": 0.0`：目标位置为 0（竖直直立的角度为零偏差）
        
- **作用**：鼓励杆子保持竖直。杆子偏离竖直越多，就会被扣更多分。
    

---

 ***(4) Shaping tasks: lower cart velocity

```python
cart_vel = RewTerm(
    func=mdp.joint_vel_l1,
    weight=-0.01,
    params={"asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"])}
)
```

- **`cart_vel`**：名称
    
- `func=mdp.joint_vel_l1`：计算所选关节速度的 L1（绝对值）范数
    
- `weight=-0.01`：小幅度惩罚速度，权重较小
    
- `params`：
    
    - `"asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"])`  
        指定“slider_to_cart”关节，即小车在轨道上的移动关节
        
- **作用**：抑制小车来回剧烈移动，促进更平稳的控制。
    

---

***(5) Shaping tasks: lower pole angular velocity

```python
pole_vel = RewTerm(
    func=mdp.joint_vel_l1,
    weight=-0.005,
    params={"asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"])}
)
```

- **`pole_vel`**：名称
    
- 与上面类似，也是对杆子关节速度做 L1 惩罚
    
- `weight=-0.005`：惩罚更小，次要的形状奖励（shaping）
    
- **作用**：减缓杆子的摆动速度，辅助主目标（保持杆子不翻倒）。
    

---

 ***整体思路

1. **存活奖励**（alive）+1/步
    
2. **失败惩罚**（terminating）-2 一次性
    
3. **主目标**（pole_pos）最小化杆偏离
    
4. **辅助目标**（cart_vel & pole_vel）分别平滑小车运动和减缓杆子摆动
    

这种将主任务和若干“奖励塑形”项（shaping terms）结合的设计，既能让 agent 明确知道“成功”的标准（杆子直立），又能避免学到一些不希望它去做的动作（高速来回乱跑、杆子剧烈摆动）。

---


# Sensor

## contact Sensor

**多足机器人接触传感器设置示例**

```python
from isaaclab import configclass, AssetBaseCfg, InteractiveSceneCfg
from isaaclab.cfgs import sim_utils, RigidObjectCfg, ContactSensorCfg, ANYMAL_C_CFG

@configclass
class ContactSensorSceneCfg(InteractiveSceneCfg):
    """Design the scene with sensors on the robot."""

    # 地面平面
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",  # 资源在场景中的路径
        spawn=sim_utils.GroundPlaneCfg()         # 使用 GroundPlaneCfg 生成地面
    )

    # 环境光源——穹顶灯
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",               # 灯光在场景中的路径
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,                    # 光照强度
            color=(0.75, 0.75, 0.75)             # 灯光颜色（RGB）
        )
    )

    # 机器人模型
    robot = ANYMAL_C_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"       # 将默认路径替换为环境命名空间下的 Robot
    )

    # 刚体对象：一个立方体
    cube = RigidObjectCfg(
        prim_path="{ENV_REGEX_NS}/Cube",        # 立方体在场景中的路径
        spawn=sim_utils.CuboidCfg(
            size=(0.5, 0.5, 0.1),                 # 立方体尺寸(x, y, z)
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),  # 刚体属性（默认）
            mass_props=sim_utils.MassPropertiesCfg(
                mass=100.0                         # 质量
            ),
            collision_props=sim_utils.CollisionPropertiesCfg(), # 碰撞属性（默认）
            physics_material=sim_utils.RigidBodyMaterialCfg(
                static_friction=1.0                # 静摩擦系数
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0),      # 表面漫反射颜色（绿色）
                metallic=0.2                        # 金属度
            ),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=(0.5, 0.5, 0.05)                  # 初始位置(x, y, z)
        ),
    )

    # 左前足触觉传感器
    contact_forces_LF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT",  # 传感器挂载在左前足
        update_period=0.0,                            # 采样周期，0 表示每帧更新
        history_length=6,                             # 历史记录长度
        debug_vis=True,                               # 显示调试可视化
        filter_prim_paths_expr=["{ENV_REGEX_NS}/Cube"],  # 仅对 Cube 物体感知接触
    )

    # 右前足触觉传感器
    contact_forces_RF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT",  # 传感器挂载在右前足
        update_period=0.0,
        history_length=6,
        debug_vis=True,
        filter_prim_paths_expr=["{ENV_REGEX_NS}/Cube"],
    )

    # 后足触觉传感器（匹配所有后足）
    contact_forces_H = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/.*H_FOOT",  # 使用正则表达式匹配所有后足
        update_period=0.0,
        history_length=6,
        debug_vis=True,
    )

```



**contac_sensor完整代码**

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Launch Isaac Sim Simulator first."""

import argparse  # 用于解析命令行参数

from isaaclab.app import AppLauncher  # 用于启动 Isaac Lab 应用

# 添加 argparse 参数
parser = argparse.ArgumentParser(description="Example on using the contact sensor.")  # 创建参数解析器，描述示例用途
parser.add_argument("--num_envs", type=int, default=1, help="Number of environments to spawn.")  # 定义环境数量参数
# 将 AppLauncher 的 CLI 参数追加到解析器中
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# 启动 Omniverse Isaac Sim 应用
app_launcher = AppLauncher(args_cli)  # 创建启动器实例
simulation_app = app_launcher.app  # 获取模拟应用对象

"""Rest everything follows."""

import torch  # 用于数值计算和张量操作

import isaaclab.sim as sim_utils  # 仿真相关工具
from isaaclab.assets import AssetBaseCfg, RigidObjectCfg  # 资产与刚体配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg  # 场景与可交互场景配置类
from isaaclab.sensors import ContactSensorCfg  # 接触传感器配置类
from isaaclab.utils import configclass  # 配置装饰器

##
# 预定义场景配置
##
from isaaclab_assets.robots.anymal import ANYMAL_C_CFG  # AnyMal 机器人基础配置


@configclass
class ContactSensorSceneCfg(InteractiveSceneCfg):
    """Design the scene with sensors on the robot."""

    # 地面平面配置
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",  # USD 路径
        spawn=sim_utils.GroundPlaneCfg()  # 使用默认地面配置
    )

    # 天光配置
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,  # 强度
            color=(0.75, 0.75, 0.75)  # 颜色
        )
    )

    # 机器人配置
    robot = ANYMAL_C_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"  # 机器人在每个环境下的 USD 路径
    )

    # 方块刚体配置
    cube = RigidObjectCfg(
        prim_path="{ENV_REGEX_NS}/Cube",  # USD 路径
        spawn=sim_utils.CuboidCfg(
            size=(0.5, 0.5, 0.1),  # 大小
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),  # 刚体属性
            mass_props=sim_utils.MassPropertiesCfg(mass=100.0),  # 质量属性
            collision_props=sim_utils.CollisionPropertiesCfg(),  # 碰撞属性
            physics_material=sim_utils.RigidBodyMaterialCfg(static_friction=1.0),  # 物理材质
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0),  # 视觉颜色
                metallic=0.2  # 金属感
            ),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=(0.5, 0.5, 0.05)  # 初始位置
        ),
    )

    # 左脚接触力传感器配置
    contact_forces_LF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT",  # 传感器挂载路径
        update_period=0.0,  # 更新周期
        history_length=6,  # 数据历史长度
        debug_vis=True,  # 调试可视化
        filter_prim_paths_expr=["{ENV_REGEX_NS}/Cube"],  # 过滤仅方块的接触
    )

    # 右脚接触力传感器配置
    contact_forces_RF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT",  # 传感器挂载路径
        update_period=0.0,
        history_length=6,
        debug_vis=True,
        filter_prim_paths_expr=["{ENV_REGEX_NS}/Cube"],
    )

    # 臀部或其他脚接触力传感器配置
    contact_forces_H = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/.*H_FOOT",  # 正则匹配任意 H_FOOT
        update_period=0.0,
        history_length=6,
        debug_vis=True,
    )


def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """Run the simulator."""
    # 获取物理步进时间
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0  # 模拟总时长
    count = 0  # 计步器

    # 开始仿真循环
    while simulation_app.is_running():

        if count % 500 == 0:
            # 每 500 步重置一次场景状态
            count = 0  # 重置计数器
            # 重置机器人根状态，使其回到默认位置
            root_state = scene["robot"].data.default_root_state.clone()
            root_state[:, :3] += scene.env_origins  # 加上环境偏移
            scene["robot"].write_root_pose_to_sim(root_state[:, :7])  # 写入根位姿
            scene["robot"].write_root_velocity_to_sim(root_state[:, 7:])  # 写入根速度
            # 设置带噪声的关节位置
            joint_pos, joint_vel = (
                scene["robot"].data.default_joint_pos.clone(),
                scene["robot"].data.default_joint_vel.clone(),
            )
            joint_pos += torch.rand_like(joint_pos) * 0.1  # 添加随机噪声
            scene["robot"].write_joint_state_to_sim(joint_pos, joint_vel)  # 写入关节状态
            # 清空传感器缓存
            scene.reset()
            print("[INFO]: Resetting robot state...")

        # 应用默认关节位置目标
        targets = scene["robot"].data.default_joint_pos  # 目标关节位置
        scene["robot"].set_joint_position_target(targets)  # 设置控制目标
        scene.write_data_to_sim()  # 将数据写入仿真
        sim.step()  # 推进物理仿真一步
        sim_time += sim_dt  # 更新时间
        count += 1  # 计步加一
        scene.update(sim_dt)  # 更新场景缓存

        # 打印传感器数据
        print("-------------------------------")
        print(scene["contact_forces_LF"])  # 打印传感器实例信息
        print("Received force matrix of: ", scene["contact_forces_LF"].data.force_matrix_w)  # 原始力/力矩矩阵
        print("Received contact force of: ", scene["contact_forces_LF"].data.net_forces_w)  # 合力向量
        print("-------------------------------")
        print(scene["contact_forces_RF"])
        print("Received force matrix of: ", scene["contact_forces_RF"].data.force_matrix_w)
        print("Received contact force of: ", scene["contact_forces_RF"].data.net_forces_w)
        print("-------------------------------")
        print(scene["contact_forces_H"])
        print("Received force matrix of: ", scene["contact_forces_H"].data.force_matrix_w)
        print("Received contact force of: ", scene["contact_forces_H"].data.net_forces_w)


def main():
    """Main function."""

    # 初始化仿真上下文
    sim_cfg = sim_utils.SimulationCfg(dt=0.005, device=args_cli.device)  # 时间步长与设备
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建仿真上下文实例
    # 设置主摄像机视角
    sim.set_camera_view(eye=[3.5, 3.5, 3.5], target=[0.0, 0.0, 0.0])
    # 设计场景
    scene_cfg = ContactSensorSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)  # 创建场景实例
    # 重置仿真
    sim.reset()
    print("[INFO]: Setup complete...")  # 提示完成
    # 运行仿真
    run_simulator(sim, scene)


if __name__ == "__main__":
    # 入口：执行 main 并关闭应用
    main()
    simulation_app.close()  # 关闭仿真应用
```

***解读


```python
import argparse
from isaaclab.app import AppLauncher
```

- `argparse`：用于从命令行读取参数。
    
- `AppLauncher`：Isaac Lab 提供的工具类，用于初始化并启动 Omniverse Isaac Sim 应用。
    

---

**命令行参数解析**

```python
parser = argparse.ArgumentParser(description="Example on using the contact sensor.")
```

- 创建一个 `ArgumentParser` 实例，并设置帮助信息描述脚本用途。
    

```python
parser.add_argument("--num_envs", type=int, default=1, help="Number of environments to spawn.")
```

- 增加 `--num_envs` 参数，指定同时创建多少个独立环境（multiple robots + objects）。
    

```python
AppLauncher.add_app_launcher_args(parser)
```

- 将 `AppLauncher` 自身所需的命令行参数（比如设备选择、渲染模式等）也注册到同一个解析器里。
    

```python
args_cli = parser.parse_args()
```

- 真正解析命令行输入，结果存入 `args_cli` 对象，后续通过 `args_cli.xxx` 访问。
    

---

**启动仿真应用**

```python
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app
```

- 用解析好的参数创建一个 `AppLauncher`，其内部会初始化 Omniverse、图形窗口、渲染器等。
    
- `app_launcher.app` 即为启动后的应用实例，后面用它来检查窗口是否关闭（`.is_running()`）或最后关闭它（`.close()`）。
    

---

**导入仿真与场景相关模块**

```python
import torch
import isaaclab.sim as sim_utils
from isaaclab.assets import AssetBaseCfg, RigidObjectCfg
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg
from isaaclab.sensors import ContactSensorCfg
from isaaclab.utils import configclass
from isaaclab_assets.robots.anymal import ANYMAL_C_CFG
```

- `torch`: 用于张量操作，添加噪声、处理状态。
    
- `sim_utils`: 包含物理仿真上下文、时间步长配置等工具。
    
- `AssetBaseCfg`、`RigidObjectCfg`: 定义场景中资产（地面、光源、可碰撞物体）的配置类。
    
- `InteractiveScene`、`InteractiveSceneCfg`: 用于搭建并管理可交互场景。
    
- `ContactSensorCfg`: 接触传感器配置。
    
- `configclass`：装饰器，把普通类转换成可以解析的“配置类”。
    
- `ANYMAL_C_CFG`: 预定义的 AnyMal 机器人配置。
    

---

**场景配置类 `ContactSensorSceneCfg`**

```python
@configclass
class ContactSensorSceneCfg(InteractiveSceneCfg):
    """Design the scene with sensors on the robot."""
```

- 继承自 `InteractiveSceneCfg`，并加上 `@configclass`，表示它定义了一个可以通过参数化来生成场景的配置。
    

```python
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",
        spawn=sim_utils.GroundPlaneCfg()
    )
```

- 在 USD 场景中添加一个地面平面，使用默认参数。
    

```python
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(intensity=3000.0, color=(0.75, 0.75, 0.75))
    )
```

- 添加全局天光，设定光强和颜色。
    

```python
    robot = ANYMAL_C_CFG.replace(prim_path="{ENV_REGEX_NS}/Robot")
```

- 把 AnyMal 机器人的 USD 路径替换为每个环境下的命名空间（`ENV_REGEX_NS`），方便批量生成多份。
    - **`ANYMAL_C_CFG`**: 这是一个预定义的机器人配置，通常包含机器人的各项参数，比如模型、关节、尺寸、材料等。
    
- **`.replace(prim_path="{ENV_REGEX_NS}/Robot")`**: 这个方法调用会将 `ANYMAL_C_CFG` 中的 `prim_path` （机器人在 USD（Universal Scene Description）文件中的路径）替换为 `{ENV_REGEX_NS}/Robot`。其中 `{ENV_REGEX_NS}` 是一个占位符，通常用于动态替换，意味着每个环境实例都会有不同的命名空间。
    

***为什么要这么做？

1. **动态命名空间**：`{ENV_REGEX_NS}` 是一个占位符，意味着该路径在多个环境中会被动态替换。这样做的好处是可以在不同的环境中创建多个机器人实例，每个实例的路径会根据环境的命名空间进行调整。
    
2. **方便批量处理**：如果你有多个仿真环境，这样替换路径的做法让每个环境中的机器人都有一个唯一的路径，使得场景中的每个机器人都能根据环境的配置自动调整，而无需手动修改路径。
    
3. **环境隔离**：通过这种方式，每个环境中的机器人可以有自己的“命名空间”，避免了不同环境之间发生路径冲突或覆盖问题。
--------

```python
    cube = RigidObjectCfg(
        prim_path="{ENV_REGEX_NS}/Cube",
        spawn=sim_utils.CuboidCfg(
            size=(0.5,0.5,0.1), 
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),
            mass_props=sim_utils.MassPropertiesCfg(mass=100.0),
            collision_props=sim_utils.CollisionPropertiesCfg(),
            physics_material=sim_utils.RigidBodyMaterialCfg(static_friction=1.0),
            visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.0,1.0,0.0), metallic=0.2),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(pos=(0.5,0.5,0.05)),
    )
```

- 在机器人旁边生成一个绿色方块，配好尺寸、质量、摩擦系数、初始位置。
    

```python
    contact_forces_LF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT",
        update_period=0.0, history_length=6, debug_vis=True,
        filter_prim_paths_expr=["{ENV_REGEX_NS}/Cube"],
    )
```

- 在左脚（LF_FOOT）挂接触传感器，只关注与方块的碰撞，历史长度 6 帧，实时可视化。
    

```python
    contact_forces_RF = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT", …
    )
```

- 同理，在右脚挂传感器。
    

```python
    contact_forces_H = ContactSensorCfg(
        prim_path="{ENV_REGEX_NS}/Robot/.*H_FOOT", …
    )
```

- 用正则表达式匹配命名中包含 `H_FOOT` 的链接，挂第三个传感器（臀部或其他脚）。
    

---

**`run_simulator` 函数**

```python
def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """Run the simulator."""
```

- 接收仿真上下文 `sim` 和已配置好的 `scene`，开始跑物理循环。
    

```python
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0
    count = 0
```

- 读取仿真的固定时间步长 `sim_dt`，初始化累计时间和步数计数器。
    

```python
    while simulation_app.is_running():
```

- 主循环：只要窗口没关，就持续仿真。
    

```python
        if count % 500 == 0:
            # 重置逻辑……
```

- 每 500 步重置一次机器人到初始状态，并给关节施加小随机噪声，清空传感器缓存，打印日志。
    

```python
        targets = scene["robot"].data.default_joint_pos
        scene["robot"].set_joint_position_target(targets)
        scene.write_data_to_sim()
```

- 生成并写入机器人的控制目标：就是让它尝试维持默认关节角度。
    

```python
        sim.step()
        sim_time += sim_dt
        count += 1
        scene.update(sim_dt)
```

- 推动物理仿真前进一步；更新时间；更新场景中所有传感器和状态的内部缓存。
    

```python
        # 打印接触传感器数据
        print("-------------------------------")
        print(scene["contact_forces_LF"])
        print("Received force matrix of: ", scene["contact_forces_LF"].data.force_matrix_w)
        print("Received contact force of: ", scene["contact_forces_LF"].data.net_forces_w)
        …（同理打印 RF、H）
```

- 从 `scene` 中按名称取出三个传感器实例：
    
    - `.data.force_matrix_w`：各接触点在世界坐标系下的力/力矩矩阵；
        
    - `.data.net_forces_w`：汇总所有点的合力向量。
        
- 每一帧都会在控制台打印出来，用于观察哪个脚与方块接触、力的大小和方向。
    

---

**入口函数 `main()`**

```python
def main():
    """Main function."""
    sim_cfg = sim_utils.SimulationCfg(dt=0.005, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view(eye=[3.5,3.5,3.5], target=[0.0,0.0,0.0])
```

- 创建 `SimulationCfg`，设置时间步长 5 毫秒和运行设备（CPU/GPU）。
    
- 用它实例化仿真上下文，并调整摄像机视角。
    

```python
    scene_cfg = ContactSensorSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)
```

- 根据命令行参数生成场景配置（环境数量、间距）。
    
- 创建并构建 `InteractiveScene`，场景中自动加载前面定义的地面、光源、机器人、方块、传感器等。
    

```python
    sim.reset()
    print("[INFO]: Setup complete...")
    run_simulator(sim, scene)
```

- 重置仿真状态，打印准备完毕，再调用上面定义的主循环函数。
    

```python
if __name__ == "__main__":
    main()
    simulation_app.close()
```

- 脚本入口：先执行 `main()`，跑完后关闭应用窗口，结束进程。
    

---
```
# ------------ 代码解读 ------------
# 1. 导入与参数解析：利用 argparse 获取 num_envs 等参数，并通过 AppLauncher 启动仿真应用。
# 2. 场景配置类(ContactSensorSceneCfg)：定义地面、光源、机器人、方块及三个接触力传感器（左脚、右脚、臀部）。
# 3. run_simulator：
#    - 设置仿真步进并进入循环，检查应用是否在运行。
#    - 每隔 500 步重置机器人状态（根位姿、关节状态），清空传感器缓存。
#    - 每步写入默认关节目标、推进仿真、更新场景缓存。
#    - 打印三个接触传感器的原始力/力矩矩阵(force_matrix_w)与合力(net_forces_w)，用于调试与分析。
# 4. main：初始化仿真上下文与摄像机、创建场景、重置仿真并调用 run_simulator。
# 5. 脚本入口：执行 main 后关闭仿真应用。

```


## frame transformer

在 **Isaac Lab** 中，**Frame Transformer** 用于在不同的坐标系（或“框架”）之间进行坐标转换。

***主要作用：

**Frame Transformer** 的主要作用是：

1. **坐标转换**：在仿真中，很多物体和机器人都有自己的局部坐标系（例如，机器人的末端执行器坐标系、摄像头坐标系等）。通过 Frame Transformer，可以将这些局部坐标系下的数据（如位置、速度等）转换为全局坐标系下的数据，反之亦然。
    
2. **解决不同物体间的坐标系关系**：有时在仿真中，不同物体或部件的坐标系之间是相对独立的。Frame Transformer 使得在物体之间进行相对转换成为可能。这在多个部件之间进行联动计算时特别重要。
    

***举例说明：

假设你有一个机器人，其关节的坐标系与全局坐标系不同。如果你想知道机器人末端执行器的位置，可能需要将末端执行器相对于机器人某个关节的位置（以关节的局部坐标系为参考）转换到全局坐标系。这时，**Frame Transformer** 就可以通过提供相应的坐标转换工具，帮助你完成这个任务。

***应用场景：

1. **传感器数据处理**：许多机器人会在不同的位置安装传感器，如相机、激光雷达等，它们通常以各自的坐标系输出数据。Frame Transformer 可以将这些传感器的坐标系转换为全局坐标系，便于后续的分析和决策。
    
2. **多机器人系统**：在多机器人环境中，每个机器人可能都有自己的坐标系。Frame Transformer 可以帮助一个机器人理解其他机器人在全局坐标系中的位置，以便进行协作或避障。
    
3. **物理仿真**：在仿真中，不同的物体（例如机器人、物体、障碍物）在物理世界中的运动是基于各自的坐标系进行的。Frame Transformer 可以帮助你理解不同物体之间的相对位置和运动，特别是在涉及力、速度、加速度等物理量时。

---

**示例代码**
```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import argparse  # 用于解析命令行参数
from isaaclab.app import AppLauncher  # 用于启动 Isaac Sim 应用

# 创建命令行参数解析器
parser = argparse.ArgumentParser(description="Example on using the frame transformer sensor.")
# 添加参数：环境数量
parser.add_argument("--num_envs", type=int, default=1, help="Number of environments to spawn.")
# 为 AppLauncher 添加必要的启动参数
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

# 下面开始正式脚本内容
import torch  # 用于张量操作和数值计算

import isaaclab.sim as sim_utils  # 仿真工具集
from isaaclab.assets import AssetBaseCfg, RigidObjectCfg  # 资产配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg  # 场景与交互式场景配置
from isaaclab.sensors import FrameTransformerCfg  # 帧变换器传感器配置
from isaaclab.utils import configclass  # 装饰器：将类标记为配置类

# 预定义机器人配置
from isaaclab_assets.robots.anymal import ANYMAL_C_CFG  # AnyMal 机器人配置


@configclass
class FrameTransformerSensorSceneCfg(InteractiveSceneCfg):
    """使用 Frame Transformer 在机器人上设置传感器的场景配置"""

    # 地面平面
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",   # USD 中地面的路径
        spawn=sim_utils.GroundPlaneCfg()          # 地面物理和渲染属性
    )

    # 天光（环境光源）
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",                 # USD 中光源的路径
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,                     # 光照强度
            color=(0.75, 0.75, 0.75)             # 光照颜色（RGB）
        )
    )

    # 机器人：使用预定义 AnyMal 配置，并设置其 USD 路径
    robot = ANYMAL_C_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"          # 在每个环境实例中放置机器人
    )

    # 刚体物体：一个绿色立方体
    cube = RigidObjectCfg(
        prim_path="{ENV_REGEX_NS}/Cube",          # USD 路径
        spawn=sim_utils.CuboidCfg(
            size=(1, 1, 1),                       # 立方体尺寸 1×1×1 米
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),    # 刚体属性
            mass_props=sim_utils.MassPropertiesCfg(mass=100.0),# 质量 100kg
            collision_props=sim_utils.CollisionPropertiesCfg(),# 碰撞属性
            physics_material=sim_utils.RigidBodyMaterialCfg(
                static_friction=1.0               # 静摩擦系数
            ),
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0),    # 绿色漫反射
                metallic=0.2                      # 金属质感
            ),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(
            pos=(5, 0, 0.5)                       # 初始位置 (x=5, y=0, z=0.5)
        ),
    )

    # 只可视化底座到左右脚的帧变换
    specific_transforms = FrameTransformerCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base",     # 源坐标系：机器人底座
        target_frames=[
            FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT"),  # 左前脚
            FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT"),  # 右前脚
        ],
        debug_vis=True                              # 开启可视化调试
    )

    # 底座到方块的帧变换，不可视化
    cube_transform = FrameTransformerCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base",     # 源：机器人底座
        target_frames=[FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Cube")],
        debug_vis=False                             # 关闭可视化
    )

    # 底座到机器人所有部件的帧变换，不可视化
    robot_transforms = FrameTransformerCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base",     # 源：机器人底座
        target_frames=[FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Robot/.*")],  # 正则匹配所有部件
        debug_vis=False                             # 关闭可视化
    )


def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """运行仿真主循环"""
    # 获取物理仿真的时间步长
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0
    count = 0

    # 只要应用在运行，就不断仿真
    while simulation_app.is_running():

        # 每 500 步重置机器人状态
        if count % 500 == 0:
            count = 0
            # 克隆默认根状态，并加上环境原点偏移
            root_state = scene["robot"].data.default_root_state.clone()
            root_state[:, :3] += scene.env_origins
            # 写入根位置和速度
            scene["robot"].write_root_pose_to_sim(root_state[:, :7])
            scene["robot"].write_root_velocity_to_sim(root_state[:, 7:])
            # 设置带噪声的关节状态
            joint_pos, joint_vel = (
                scene["robot"].data.default_joint_pos.clone(),
                scene["robot"].data.default_joint_vel.clone(),
            )
            joint_pos += torch.rand_like(joint_pos) * 0.1
            scene["robot"].write_joint_state_to_sim(joint_pos, joint_vel)
            # 清空内部缓存
            scene.reset()
            print("[INFO]: Resetting robot state...")

        # 机器人执行默认位置控制
        targets = scene["robot"].data.default_joint_pos  # 目标关节位置
        scene["robot"].set_joint_position_target(targets)
        scene.write_data_to_sim()  # 写入动作到仿真
        sim.step()                 # 物理步进
        sim_time += sim_dt
        count += 1
        scene.update(sim_dt)       # 更新传感器与场景

        # 打印传感器输出
        print("-------------------------------")
        print(scene["specific_transforms"])
        print("relative transforms:", scene["specific_transforms"].data.target_pos_source)
        print("relative orientations:", scene["specific_transforms"].data.target_quat_source)
        print("-------------------------------")
        print(scene["cube_transform"])
        print("relative transform:", scene["cube_transform"].data.target_pos_source)
        print("-------------------------------")
        print(scene["robot_transforms"])
        print("relative transforms:", scene["robot_transforms"].data.target_pos_source)


def main():
    """主函数，初始化并启动仿真"""
    # 创建仿真配置，设置时间步长和设备（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(dt=0.005, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    # 设置主摄像机视角
    sim.set_camera_view(eye=[3.5, 3.5, 3.5], target=[0.0, 0.0, 0.0])

    # 构建场景配置并创建场景
    scene_cfg = FrameTransformerSensorSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)

    # 重置仿真并启动主循环
    sim.reset()
    print("[INFO]: Setup complete...")
    run_simulator(sim, scene)


if __name__ == "__main__":
    main()                    # 执行主函数
    simulation_app.close()    # 关闭仿真应用

```

**代码重点**

```python
    specific_transforms = FrameTransformerCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base",
        target_frames=[
            FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT"),
            FrameTransformerCfg.FrameCfg(prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT"),
        ],
        debug_vis=True,
    )

```

这段代码的 `specific_transforms` 配置创建了一个 **底座相对于前脚的坐标变换**，其主要功能是将机器人的底座（`base`）和左右前脚（`LF_FOOT`, `RF_FOOT`）之间的相对位置和姿态计算出来。

具体来说：

- **`prim_path="{ENV_REGEX_NS}/Robot/base"`**  
    这里的 `prim_path` 指定了坐标系的 **源**，即机器人底座 (`base`)。这个源坐标系会作为参考坐标系，用来计算其他坐标系的相对位置。
    
- **`target_frames=[...]`**  
    这里指定了两个目标坐标系：机器人左前脚 (`LF_FOOT`) 和右前脚 (`RF_FOOT`)。这些是 **目标坐标系**，我们要计算的就是底座到这些目标坐标系的相对坐标变换。
    
- **`debug_vis=True`**  
    开启可视化调试，意味着在仿真中可以直观地看到源坐标系（底座）和目标坐标系（左右前脚）之间的相对变换，通常通过画出坐标轴或箭头来展示它们之间的位置和朝向变化。

==计算过程==：

- **底座到前脚的相对变换**：
    
    - 算法会计算出底座 (`base`) 到左前脚 (`LF_FOOT`) 和右前脚 (`RF_FOOT`) 之间的位置差异和旋转差异。
        
    - 这些变换可以表示为相对的 **位置（position）** 和 **朝向（orientation）**，即相对于底座来说，左前脚和右前脚分别位于什么位置，朝哪个方向。
        

==可视化==：

- 启用可视化（`debug_vis=True`）后，仿真界面会显示这些坐标系之间的转换信息，例如：
    
    - 通过箭头或坐标系图标，展示从底座到左右前脚的相对变换，便于直观理解它们之间的空间关系。

---

## IMU

示例代码：

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""启动 Isaac Sim 仿真器"""

import argparse  # 用于解析命令行参数
from isaaclab.app import AppLauncher  # 用于启动 Isaac Sim 应用

# 创建命令行参数解析器
parser = argparse.ArgumentParser(description="Example on using the IMU sensor.")
# 添加参数：环境数量
parser.add_argument("--num_envs", type=int, default=1, help="Number of environments to spawn.")
# 为 AppLauncher 添加必要的启动参数
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""下面开始脚本主体"""

import torch  # 用于张量运算

import isaaclab.sim as sim_utils  # 仿真工具集
from isaaclab.assets import AssetBaseCfg  # 资产配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg  # 场景管理
from isaaclab.sensors import ImuCfg  # IMU 传感器配置类
from isaaclab.utils import configclass  # 标记配置类的装饰器

# 预定义 AnyMal 机器人配置
from isaaclab_assets.robots.anymal import ANYMAL_C_CFG  # isort: skip


@configclass
class ImuSensorSceneCfg(InteractiveSceneCfg):
    """在机器人上添加 IMU 传感器的场景配置"""

    # 地面平面
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",  # USD 中地面的路径
        spawn=sim_utils.GroundPlaneCfg()           # 地面物理和渲染属性
    )

    # 天光（环境光源）
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",  # USD 中光源的路径
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,        # 光照强度
            color=(0.75, 0.75, 0.75)  # 光照颜色
        )
    )

    # 机器人：使用预定义 AnyMal 配置，并设置 USD 路径
    robot = ANYMAL_C_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"  # 在每个环境中放置机器人
    )

    # 在左前脚挂载一个 IMU 传感器，并开启可视化调试
    imu_RF = ImuCfg(
        prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT",  # IMU 所在的 prim 路径
        debug_vis=True                             # 可视化显示坐标系
    )

    # 在右前脚挂载另一个 IMU 传感器，设置重力偏置并可视化
    imu_LF = ImuCfg(
        prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT",  # IMU 所在的 prim 路径
        gravity_bias=(0, 0, 0),                    # 手动设置的重力偏置
        debug_vis=True                             # 可视化显示坐标系
    )


def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """运行仿真主循环"""
    sim_dt = sim.get_physics_dt()  # 获取物理步长
    sim_time = 0.0
    count = 0

    while simulation_app.is_running():

        if count % 500 == 0:
            count = 0
            # 重置机器人状态（根状态和关节状态）
            root_state = scene["robot"].data.default_root_state.clone()
            root_state[:, :3] += scene.env_origins
            scene["robot"].write_root_link_pose_to_sim(root_state[:, :7])
            scene["robot"].write_root_com_velocity_to_sim(root_state[:, 7:])
            joint_pos, joint_vel = (
                scene["robot"].data.default_joint_pos.clone(),
                scene["robot"].data.default_joint_vel.clone(),
            )
            joint_pos += torch.rand_like(joint_pos) * 0.1
            scene["robot"].write_joint_state_to_sim(joint_pos, joint_vel)
            scene.reset()  # 清空传感器和内部缓存
            print("[INFO]: Resetting robot state...")

        # 应用默认关节目标并步进仿真
        targets = scene["robot"].data.default_joint_pos
        scene["robot"].set_joint_position_target(targets)
        scene.write_data_to_sim()
        sim.step()
        sim_time += sim_dt
        count += 1
        scene.update(sim_dt)

        # 打印 IMU 传感器输出
        print("-------------------------------")
        print(scene["imu_LF"])
        print("线速度 (机体坐标系):", scene["imu_LF"].data.lin_vel_b)
        print("角速度 (机体坐标系):", scene["imu_LF"].data.ang_vel_b)
        print("线加速度 (机体坐标系):", scene["imu_LF"].data.lin_acc_b)
        print("角加速度 (机体坐标系):", scene["imu_LF"].data.ang_acc_b)
        print("-------------------------------")
        print(scene["imu_RF"])
        print("线速度 (机体坐标系):", scene["imu_RF"].data.lin_vel_b)
        print("角速度 (机体坐标系):", scene["imu_RF"].data.ang_vel_b)
        print("线加速度 (机体坐标系):", scene["imu_RF"].data.lin_acc_b)
        print("角加速度 (机体坐标系):", scene["imu_RF"].data.ang_acc_b)


def main():
    """主函数：初始化并启动仿真"""
    sim_cfg = sim_utils.SimulationCfg(dt=0.005, device=args_cli.device)  # 仿真配置
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view(eye=[3.5, 3.5, 3.5], target=[0.0, 0.0, 0.0])  # 设置相机视角
    scene_cfg = ImuSensorSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)
    sim.reset()
    print("[INFO]: Setup complete...")
    run_simulator(sim, scene)


if __name__ == "__main__":
    main()
    simulation_app.close()  # 关闭仿真应用

```

 **IMU 部分** 的==核心内容==：

1. **IMU 传感器的配置**  
    在 `ImuSensorSceneCfg` 配置类里，我们通过两个字段 `imu_RF` 和 `imu_LF` 分别定义了挂载在机器人左右两只前脚上的 IMU 传感器：
    
    ```python
    imu_RF = ImuCfg(
        prim_path="{ENV_REGEX_NS}/Robot/LF_FOOT",  # 指定 IMU 安装在左前脚的 Xform Prim 上
        debug_vis=True                             # 在场景中可视化该 IMU 的坐标系
    )
    
    imu_LF = ImuCfg(
        prim_path="{ENV_REGEX_NS}/Robot/RF_FOOT",  # 指定 IMU 安装在右前脚的 Xform Prim 上
        gravity_bias=(0, 0, 0),                    # 手动设置的重力补偿偏置
        debug_vis=True                             # 可视化该 IMU 的坐标系
    )
    ```
    
    - `prim_path`：指定 IMU 在 USD 场景中的挂载位置。这里用环境命名空间替换 (`{ENV_REGEX_NS}`)，保证多环境实例之间互不干扰。
        
    - `gravity_bias`（可选）：IMU 内部通常会自动补偿重力加速度；通过这个参数可以手动覆盖或校准重力偏置。
        
    - `debug_vis`：开启后，仿真界面会显示该 IMU 参考坐标系，便于调试传感器姿态。
        
2. **数据读取与打印**  
    在 `run_simulator` 主循环中，每一步仿真更新 (`scene.update(sim_dt)`) 后，代码从这两个 IMU 传感器实例中读取并打印四组数据：
    
    ```python
    # 对 imu_LF（右前脚 IMU）读取：
    scene["imu_LF"].data.lin_vel_b   # 机体坐标系下的线速度
    scene["imu_LF"].data.ang_vel_b   # 机体坐标系下的角速度
    scene["imu_LF"].data.lin_acc_b   # 机体坐标系下的线加速度
    scene["imu_LF"].data.ang_acc_b   # 机体坐标系下的角加速度
    
    # 对 imu_RF（左前脚 IMU）读取：
    scene["imu_RF"].data.lin_vel_b
    scene["imu_RF"].data.ang_vel_b
    scene["imu_RF"].data.lin_acc_b
    scene["imu_RF"].data.ang_acc_b
    ```
    
    - **`lin_vel_b`**：IMU 本体坐标系下的线速度（线性速度）。
        
    - **`ang_vel_b`**：IMU 本体坐标系下的角速度。
        
    - **`lin_acc_b`**：IMU 本体坐标系下的线加速度，包含了重力分量（除非被 `gravity_bias` 调整）。
        
    - **`ang_acc_b`**：IMU 本体坐标系下的角加速度，通常由物理仿真引擎计算得到。
        
3. **重置与循环逻辑**
    
    - 每 500 步仿真会重置机器人状态（根状态与关节状态），并清空传感器内部缓存，保证数据不会累积。
        
    - IMU 数据在每一步更新后立刻可用，通过 `scene.update(sim_dt)` 同步到 `scene["imu_*"].data` 中。
        

这样，你就可以在仿真过程中实时获得并可视化附加在机器人脚部的 IMU 传感器输出，包括速度、加速度和角速度信息，用于后续感知和控制算法的开发与验证。


---


## Ray Caster射线投射器

在 Isaac Lab 里，**Ray Caster** 是一种基于光线投射（ray‐casting）的通用距离测量工具／传感器接口，它的核心功能就是从某个发射点朝指定方向发出“射线”，在场景中检测这条射线首次跟哪些几何体相交，并返回距离信息。其典型应用包括：

1. **模拟激光雷达（LiDAR）或深度相机**
    
    - 你可以配置一组方向和俯仰角，批量发射上千条射线，对周围环境做扫描，得到一个点云或深度图。
        
    - 支持多种投射模式：单线扫、旋转扫描、面阵扫描等。
        
2. **近距离测距／避障传感**
    
    - 少量射线也可以用来做障碍物检测、跟踪距离（例如前置碰撞预警）。
        
    - 这在机器人避障或自动驾驶中非常常见。

--------
示例代码：

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import argparse  # 命令行参数解析
import numpy as np  # 数值运算

from isaaclab.app import AppLauncher  # Omniverse 应用启动器

# 添加并解析命令行参数
parser = argparse.ArgumentParser(description="示例：使用 Ray Caster 传感器。")
parser.add_argument("--num_envs", type=int, default=1, help="要生成的环境数量。")
AppLauncher.add_app_launcher_args(parser)  # 添加 AppLauncher 的参数
args_cli = parser.parse_args()

# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

# 脚本主体开始
import torch  # 张量运算

import isaaclab.sim as sim_utils  # 仿真工具
from isaaclab.assets import AssetBaseCfg  # 资产配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg  # 场景管理
from isaaclab.sensors.ray_caster import RayCasterCfg, patterns  # Ray Caster 及其扫描模式
from isaaclab.utils import configclass  # 标记配置类
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR  # 资源路径常量

# 预定义 AnyMal 机器人配置
from isaaclab_assets.robots.anymal import ANYMAL_C_CFG  # isort: skip


@configclass
class RaycasterSensorSceneCfg(InteractiveSceneCfg):
    """在机器人上添加 Ray Caster 传感器的场景配置"""

    # 地面环境：加载 rough_plane.usd
    ground = AssetBaseCfg(
        prim_path="/World/Ground",
        spawn=sim_utils.UsdFileCfg(
            usd_path=f"{ISAAC_NUCLEUS_DIR}/Environments/Terrains/rough_plane.usd",
            scale=(1, 1, 1),  # 缩放
        ),
    )

    # 环境光：Dome Light
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,  # 光照强度
            color=(0.75, 0.75, 0.75)  # 光照颜色
        )
    )

    # 机器人：AnyMal C
    robot = ANYMAL_C_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"  # 每个环境的机器人根路径
    )

    # Ray Caster 传感器配置
    ray_caster = RayCasterCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base/lidar_cage",  # 传感器挂载位置
        update_period=1/60,  # 更新频率（秒）
        offset=RayCasterCfg.OffsetCfg(pos=(0, 0, 0.5)),  # 相对机器人底座的偏移
        mesh_prim_paths=["/World/Ground"],  # 要检测的网格路径列表
        attach_yaw_only=True,  # 仅跟随机器人的偏航角度
        pattern_cfg=patterns.LidarPatternCfg(
            channels=100,  # 垂直通道数
            vertical_fov_range=[-90, 90],  # 垂直视场角范围
            horizontal_fov_range=[-90, 90],  # 水平视场角范围
            horizontal_res=1.0,  # 水平分辨率（度）
        ),
        debug_vis=not args_cli.headless,  # 是否可视化射线
    )


def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """运行仿真主循环"""
    sim_dt = sim.get_physics_dt()  # 物理步长
    sim_time = 0.0
    count = 0

    triggered = True
    countdown = 42

    while simulation_app.is_running():

        if count % 500 == 0:
            count = 0
            # 重置机器人根状态和关节状态，清空缓存
            root_state = scene["robot"].data.default_root_state.clone()
            root_state[:, :3] += scene.env_origins
            scene["robot"].write_root_pose_to_sim(root_state[:, :7])
            scene["robot"].write_root_velocity_to_sim(root_state[:, 7:])
            joint_pos, joint_vel = (
                scene["robot"].data.default_joint_pos.clone(),
                scene["robot"].data.default_joint_vel.clone(),
            )
            joint_pos += torch.rand_like(joint_pos) * 0.1
            scene["robot"].write_joint_state_to_sim(joint_pos, joint_vel)
            scene.reset()
            print("[INFO]: Resetting robot state...")

        # 应用默认关节目标并步进
        targets = scene["robot"].data.default_joint_pos
        scene["robot"].set_joint_position_target(targets)
        scene.write_data_to_sim()
        sim.step()
        sim_time += sim_dt
        count += 1
        scene.update(sim_dt)

        # 打印 Ray Caster 信息
        print("-------------------------------")
        print(scene["ray_caster"])
        print("Ray cast hit results:", scene["ray_caster"].data.ray_hits_w)

        # 条件触发：保存一次点云数据
        if not triggered:
            if countdown > 0:
                countdown -= 1
                continue
            data = scene["ray_caster"].data.ray_hits_w.cpu().numpy()
            np.save("cast_data.npy", data)
            triggered = True
        else:
            continue


def main():
    """主函数：初始化并启动仿真"""
    sim_cfg = sim_utils.SimulationCfg(dt=0.005, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view(eye=[3.5, 3.5, 3.5], target=[0.0, 0.0, 0.0])
    scene_cfg = RaycasterSensorSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)
    sim.reset()
    print("[INFO]: Setup complete...")
    run_simulator(sim, scene)


if __name__ == "__main__":
    main()
    simulation_app.close()  # 关闭应用

```

 **Ray Caster 传感器** 的核心部分：

1. **挂载位置与更新频率**
    
    ```python
    ray_caster = RayCasterCfg(
        prim_path="{ENV_REGEX_NS}/Robot/base/lidar_cage",  # 传感器挂载于机器人底座上的一个 cage prim
        update_period=1/60,                               # 每秒更新 60 次
        offset=RayCasterCfg.OffsetCfg(pos=(0, 0, 0.5)),    # 在底座之上 0.5m 处发射射线
        ...
    )
    ```
    
    - `prim_path` 定义了 Ray Caster 在 USD 场景中的挂载点。这里使用一个名为 `lidar_cage` 的空 Xform 作为射线发射机构。
        
    - `update_period` 设置了射线发射和检测的周期（秒）。在 1/60s 的周期中，仿真会以 60Hz 的频率进行一次完整的射线查询。
        
2. **检测目标网格**
    
    ```python
    mesh_prim_paths=["/World/Ground"],  # 只检测地面网格
    ```
    
    - 通过 `mesh_prim_paths` 指定了要与射线进行相交检测的几何体 Prim。这里仅检测地面 (`rough_plane.usd`) 的碰撞几何。
        
3. **姿态跟随**
    
    ```python
    attach_yaw_only=True,
    ```
    
    - 如果为 `True`，Ray Caster 仅跟随挂载物体的偏航（绕 Z 轴旋转），而保持俯仰和翻滚不变。
        
    - 这样可以模拟水平旋转扫描（如常见的 2D LiDAR），即扫描平面始终与水平面平行。
        
4. **扫描模式配置**
    
    ```python
    pattern_cfg=patterns.LidarPatternCfg(
        channels=100,                   # 垂直方向上的射线层数
        vertical_fov_range=[-90, 90],   # 垂直视场角从 -90° 到 +90°
        horizontal_fov_range=[-90, 90], # 水平视场角从 -90° 到 +90°
        horizontal_res=1.0              # 水平分辨率：1°/射线
    ),
    ```
    
    - `channels`：垂直方向上同时发射多少条射线（即扫描层数）。
        
    - `vertical_fov_range`：从下往上覆盖的垂直视场范围。
        
    - `horizontal_fov_range`：左右两侧的水平视场范围。
        
    - `horizontal_res`：扫描时每隔多少度发射一束射线。这里从 -90° 到 +90°，每 1° 一束，即发射 181 条水平射线。
        
5. **调试可视化**
    
    ```python
    debug_vis=not args_cli.headless,
    ```
    
    - 如果不是无头模式，将在场景中可视化射线的投射轨迹，帮助调试扫描模式、位置和方向是否正确。
        
6. **数据读取与保存**
    
    - 在主循环中，通过 `scene.update(sim_dt)` 同步后，可从
        
        ```python
        scene["ray_caster"].data.ray_hits_w
        ```
        
        获取所有射线在世界坐标系下的相交点坐标（若某条射线未命中，会返回某个默认值，如 `[inf, inf, inf]`）。
        
    - 代码中示例性地每次触发时，将这些点云数据转换为 NumPy 数组并保存到 `cast_data.npy` 中，便于后续分析和可视化。
        

---

**总结**：  
Isaac Lab 的 Ray Caster 提供了一套灵活的、纯几何的光线投射接口，用于模拟各种距离传感——从经典的激光雷达 LiDAR（多线/360°扫描）到简单的距离探测（少量射线或单方向测距）。它并不模拟波动物理特性（如回波强度或多普勒效应），但在需要高效获取场景几何信息时非常实用。



----

# Motion Generators（运动发生器）
[Motion Generators — Isaac Lab Documentation](https://isaac-sim.github.io/IsaacLab/main/source/overview/core-concepts/motion_generators.html)
机器人任务通常在任务空间（task-space）中以期望的末端执行器轨迹来定义，而控制动作则在关节空间（joint-space）内执行。由此自然衍生了关节空间与任务空间（也称操作空间，operational-space）的控制方法。然而，仅靠运动控制要想在交互任务中取得成功，通常需要对机器人本体与环境都有较为精准的模型。虽然我们往往能获得较为精确的机械臂模型，但环境的详细描述却难以获取。因模型不匹配而产生的规划误差，可以通过在交互过程中引入“顺应性”（compliance）来克服。

---

***主动交互控制方法分类

在此我们侧重于**主动顺应性控制**（active interaction control），主要分为两大类：

1. **阻抗控制（Impedance Control）**
    
    - 间接控制方法，将交互过程中产生的运动偏差视作一个可调参数的质量—弹簧—阻尼系统（mass-spring-damper）。
        
    - 可调参数包括刚度（stiffness）与阻尼（damping）。
        
    - 其中，**刚度控制（Stiffness Control）**是一个特殊情况，仅考虑位置误差与接触力之间的静态关系。
        
2. **力／运动混合控制（Hybrid Force/Motion Control）**
    
    - 主动控制方法：在任务的受约束方向上控制力，在非受约束方向上控制运动。
        
    - 本文实现基于操作空间的逆动力学控制（inverse dynamics control in operational space）方案[Kha87](https://isaac-sim.github.io/IsaacLab/main/source/refs/bibliography.html#id4)。
        

---

> [!NOTE] **Note**  
> 为了提供更丰富的运动发生器实现，我们欢迎社区贡献！  
> 如果您有兴趣，请打开一个 Issue，开始讨论。

---

## 关节空间控制器

#### 力矩控制 (Torque Control)

- **动作维度**：`n`（关节数量）
    
- **原理**：在力矩控制模式下，输入动作直接作为前馈关节力矩命令，即在每个时间步：
    
$$
    \tau = \tau_{\mathrm{des}}
$$
- **配置方法**：通过 `ActuatorControlCfg` 类将执行器组的命令类型设置为 `"t_abs"` 即可启用此模式。
    

---

#### 速度控制 (Velocity Control)

- **动作维度**：`n`（关节数量）
    
- **原理**：使用比例控制律来减小当前关节速度  $\dot q$ 与期望关节速度 $\dot q_{\mathrm{des}}$ 之间的误差。关节力矩命令计算为：
    
$$
    \tau = k_d\,(\dot q_{\mathrm{des}} - \dot q)
$$
    
    其中 $k_d$ 为从配置文件中解析得到的增益。
    
- **配置方法**：通过 `ActuatorControlCfg` 类将执行器组的命令类型设置为 `"v_abs"` 或 `"v_rel"` 即可启用此模式。
    

> [!NOTE] **注意**  
> 在速度控制中，通常需要进行重力补偿以提高跟踪精度。  
> —— 在仿真环境下，可考虑禁用运动链各关节的重力影响。


### 固定阻抗的位置控制 (Position Control with Fixed Impedance)

**动作维度**：`n`（关节数量）

---

#### 简单形式（PD 控制）

在位置控制模式下，采用比例-阻尼（PD）控制律来跟踪期望关节位置，同时确保机械臂保持在目标位置（即`期望关节速度为零`）。根据输入动作，计算得到的关节力矩命令为：

$$
\tau = k_p\,(q_{\mathrm{des}} - q)\;-\;k_d\,\dot q
$$

- $k_p$, $k_d$：从配置中解析得到的比例和阻尼增益
    
- $q_{\mathrm{des}}$：期望关节位置
    
- $q$、$\dot q$：当前关节位置和速度
    

**启用方法**：  
通过 `ActuatorControlCfg` 类，将执行器组（actuator group）的命令类型设置为 `"p_abs"` 或 `"p_rel"`。

---

#### 完整形式（考虑动力学）

若要考虑机械臂的惯性和重力，可使用更完整的逆动力学形式：

$$
\tau = M\bigl(k_p\,(q_{\mathrm{des}} - q)\;-\;k_d\,\dot q\bigr)\;+\;g
$$

- $M$：$n \times n$ 关节空间惯性矩阵
    
- $g$ ：关节空间重力向量
    

**启用方法**：  
通过 `JointImpedanceController` 类，将阻抗模式（impedance mode）设置为 `"fixed"`。

---

##### 阻尼增益的计算

当将系统视作解耦的点质量振子（point-mass oscillator）时，阻尼增益可按以下公式计算：

$$
k_d = 2\,\sqrt{k_p }\times D
$$

- D：系统阻尼比
    
    - D = 1 时为临界阻尼
        
    - D > 1 为过阻尼
        
    - D < 1 为欠阻尼
        

---

> [!NOTE] **注意**  
> 如需关闭惯性补偿或重力补偿，可在配置中将 `inertial_compensation` 或 `gravity_compensation` 标志分别设为 `False`。


### 可变刚度的位置控制  
**动作维度：** “2n”（关节数量）

在刚度控制中，采用与上述相同的公式，但增益 `kp` 是输入命令的一部分。通过将 `JointImpedanceController` 类的阻抗模式设置为 `"variable_kp"` 即可使用此实现。

---

### 可变阻抗的位置控制  
**动作维度：** “3n”（关节数量）

在阻抗控制中，采用与上述相同的公式，但 `kp` 和 `kd` 均是输入命令的一部分。通过将 `JointImpedanceController` 类的阻抗模式设置为 `"variable"` 即可使用此实现。

---

## 任务空间控制器

### 微分逆运动学 (IK)

**动作维度：** “3”（相对／绝对位置）、“6”（相对位姿）、或 “7”（绝对位姿）

逆运动学将任务空间的跟踪误差转换为关节空间的误差。在最典型的实现中，任务空间的位姿误差

$$
\Delta x_e = (\Delta p_e, \,\Delta\phi_e)
$$

被计算为期望与当前任务空间位置之间的笛卡尔距离，以及期望与当前任务空间姿态在 SO(3) 群上的最短距离。

利用将任务空间速度映射到关节空间速度的几何雅可比矩阵

$$
J_{e\!o}\in\mathbb R^{6\times n}
$$

我们设计控制律以获得期望的关节位置：

$$
q_{\rm des} \;=\; q \;+\; \eta\,J_{e\!o}^{-}\,\Delta x_e
$$

其中 $\eta$ 是缩放参数，$J_{e\!o}^{-}$ 是雅可比矩阵的伪逆。

可以使用不同的形式来计算雅可比矩阵的伪逆：

- **Moore–Penrose 伪逆**：
    
$$
    A^{-} = A^{T}(A\,A^{T})^{-1}
$$
- **Levenberg–Marquardt 伪逆（阻尼最小二乘）**：
    
$$
    A^{-} = A^{T}(A\,A^{T} + \lambda I)^{-1}
$$
- **转置伪逆**：
    
$$
    A^{-} = A^{T}
$$
- **自适应奇异值分解 (SVD) 伪逆**（ [Buss](https://isaac-sim.github.io/IsaacLab/main/source/refs/bibliography.html#id7)）
    

这些实现可通过 `DifferentialInverseKinematics` 类获得。

**阻抗控制器**  
它使用任务空间的位姿误差和雅可比矩阵，通过质–弹–阻系统计算关节力矩，支持：

1. 固定刚度（fixed stiffness）
    
2. 可变刚度（刚度控制，variable stiffness）
    
3. 可变刚度与可变阻尼（阻抗控制，variable stiffness and damping）
    

**操作空间控制器**  
与任务空间阻抗控制类似，但在计算任务空间力时直接采用系统的运动方程（Equation of Motion, EoM）。

**闭环比例力控制器**  
使用比例环节跟踪末端执行器的期望力/力矩指令与当前力/力矩之间的偏差。

**混合力–运动控制器**  
将闭环力控制与操作空间运动控制相结合，以计算末端执行器的期望力/力矩。其利用选择矩阵来定义各任务方向的受约束与非受约束子空间。

**反应式规划器**  
典型的任务空间控制器不考虑关节限位、自身碰撞和环境碰撞等运动学约束，通常依赖高层规划器（如 RRT）生成关节或任务空间路径点，效果较为保守且在靠近障碍物时出现不理想的减速现象。近年来，已有不同方法将这些非欧几里得约束直接整合到优化问题中，从而为运动生成与控制提供整体化解决方案。

当前支持以下反应式规划器：

- **RMPFlow（lula）**  
    基于加速度的策略，通过组合多条黎曼运动策略（Riemannian Motion Policies, RMPs）来分层求解多任务问题，并能在动态环境中实现动态避碰与末端执行器导航 [CMI+21](https://isaac-sim.github.io/IsaacLab/main/source/refs/bibliography.html#id6)。
    
- **MPC（OCS2）**  
    基于序列线性二次（SLQ）规划的递推时域（receding horizon）控制策略，将多种约束以软罚项形式统一为单次优化问题，并通过自动微分计算系统动力学、约束和代价函数的导数。目前支持对定臂和移动型机械臂的末端执行器轨迹跟踪的 MPC 形式化，考虑了关节限位与自身碰撞避障的运动学系统模型 [MHF+22](https://isaac-sim.github.io/IsaacLab/main/source/refs/bibliography.html#id9)。
    

> [!NOTE] **注意**  
> 我们对上述反应式规划器的 Python 绑定进行了封装，以便批量计算机器人动作；但由于当前实现均基于 CPU，可能在训练或在线学习过程中产生一定的性能瓶颈。

---