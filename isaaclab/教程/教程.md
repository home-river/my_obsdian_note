

# 创建空舞台

```python
"""这个脚本演示了如何在 Isaac Sim 中创建一个简单的场景（舞台）。

.. code-block:: bash

    # 使用方法
    ./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py

"""

"""请先启动 Isaac Sim 模拟器。"""

import argparse  # 导入命令行参数解析模块

from isaaclab.app import AppLauncher  # 从 isaaclab.app 中导入 AppLauncher 类

# 创建命令行参数解析器
parser = argparse.ArgumentParser(description="创建空舞台的教程。")
# 将 AppLauncher 的命令行参数添加到解析器中
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
# 获取模拟应用实例
simulation_app = app_launcher.app

"""下面的代码开始主体逻辑。"""

from isaaclab.sim import SimulationCfg, SimulationContext  # 导入模拟配置和上下文类


def main():
    """主函数入口。"""

    # 初始化模拟配置，设置时间步长 dt
    sim_cfg = SimulationCfg(dt=0.01)
    # 创建模拟上下文
    sim = SimulationContext(sim_cfg)
    # 设置主摄像机位置和观察目标
    sim.set_camera_view([2.5, 2.5, 2.5], [0.0, 0.0, 0.0])

    # 重置模拟
    sim.reset()
    # 模拟设置完成提示
    print("[INFO]: 设置完成...")

    # 开始物理模拟循环
    while simulation_app.is_running():
        # 执行一步模拟
        sim.step()


# 如果脚本作为主程序执行，则运行 main 函数并关闭应用
if __name__ == "__main__":
    # 调用主函数
    main()
    # 关闭模拟应用
    simulation_app.close()

```


`SimulationCfg` 的构造函数可以接受多个参数。以下是一些常见的配置参数（具体可参考 Isaac Lab 文档或源码）：

- `dt`：仿真时间步长（秒），即每次 `step()` 前进的模型时间。
    
- `gravity`：重力向量，通常是一个 3 元组或列表，例如 `[0, 0, -9.81]`。
    
- `use_gpu`：布尔值，是否在 GPU 上运行物理仿真。
    
- `up_axis`：场景的上方向，可以是字符串 `"Z"` 或者 `"Y"`，决定重力方向等。
    
- `solver_iterations`：物理求解器迭代次数，影响模拟精度与速度。
    
- `substeps`：每个渲染帧内进行的物理子步数量，用于更精细的物理计算。
    
- `enable_flatcache`：布尔值，是否开启 Omniverse 的扁平缓存加速。
    
- 更多高级选项，如碰撞参数、渲染选项等。
    

示例：

```python
sim_cfg = SimulationCfg(
    dt=0.01,
    gravity=[0.0, 0.0, -9.81],
    use_gpu=True,
    up_axis="Z",
    solver_iterations=10,
    substeps=2
)
```


```python
sim = SimulationContext(sim_cfg)
```

的作用就是根据你传入的配置（`sim_cfg`）初始化并创建一个新的、“空”的模拟环境（舞台）。此时，所有的模拟状态、实体、事件队列等都还没被填充或启动，就像一个刚搭建好的戏台，还没有上演员和道具。后续你可以往这个 `sim` 对象里添加参数、注册实体、推进时间步等操作，都将在这个空白舞台上进行。


---

# 为场景添加基本物体
[生成基本物体到场景中 — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/00_sim/spawn_prims.html)


```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""脚本演示了怎么往stage添加基本物体.

.. code-block:: bash

    # 用法
    ./isaaclab.sh -p scripts/tutorials/00_sim/spawn_prims.py

"""

"""Launch Isaac Sim Simulator first."""

import argparse
from isaaclab.app import AppLauncher

# 创建命令行参数解析器，用于接收脚本运行时的参数
parser = argparse.ArgumentParser(description="Tutorial on spawning prims into the scene.")
# 向解析器添加 Isaac Lab 应用启动器的专用参数（如 --headless, --device 等）
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 根据解析到的 CLI 参数创建并启动 Omniverse Isaac Sim 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取启动后的应用实例

"""后续所有逻辑都在 Isaac Sim 应用中执行"""
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR


def design_scene():
    """在场景中生成地面、光源、基本原语和 USD 模型等对象"""
    # 1. 生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # 调用 config 的 func 方法，将地面 prim 添加到 /World/defaultGroundPlane
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2. 生成远处光源（Distant Light）
    cfg_light_distant = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光源强度
        color=(0.75, 0.75, 0.75),         # 灰白色光
    )
    # 将远处光源放置在世界坐标 (1,0,10)
    cfg_light_distant.func(
        "/World/lightDistant", cfg_light_distant,
        translation=(1, 0, 10)
    )

    # 3. 在 /World/ 下创建一个空的 Xform prim，用作后续所有对象的父节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 4. 生成两个红色实心圆锥
    cfg_cone = sim_utils.ConeCfg(
        radius=0.15,                       # 半径
        height=0.5,                        # 高度
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 0.0, 0.0)  # 红色材质
        ),
    )
    # 将圆锥放置在不同位置
    cfg_cone.func("/World/Objects/Cone1", 
				  cfg_cone,
				  translation=(-1.0, 1.0, 1.0))
    cfg_cone.func("/World/Objects/Cone2", 
			      cfg_cone,
				  translation=(-1.0, -1.0, 1.0))

    # 5. 生成一个带物理属性（刚体）的绿色圆锥
    cfg_cone_rigid = sim_utils.ConeCfg(
        radius=0.15,
        height=0.5,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(),         # 刚体属性
        mass_props=sim_utils.MassPropertiesCfg(mass=1.0),      # 质量属性
        collision_props=sim_utils.CollisionPropertiesCfg(),    # 碰撞属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 1.0, 0.0)  # 绿色材质
        ),
    )
    # 设置位置和旋转四元数
    cfg_cone_rigid.func(
        "/World/Objects/ConeRigid", cfg_cone_rigid,
        translation=(-0.2, 0.0, 2.0),
        orientation=(0.5, 0.0, 0.5, 0.0)
    )

    # 6. 生成一个可变形的蓝色长方体
    cfg_cuboid_deformable = sim_utils.MeshCuboidCfg(
        size=(0.2, 0.5, 0.2),                                  # 尺寸 (X, Y, Z)
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(),  # 可变形物体属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 0.0, 1.0)                      # 蓝色材质
        ),
        physics_material=sim_utils.DeformableBodyMaterialCfg(),  # 可变形材质属性
    )
    cfg_cuboid_deformable.func("/World/Objects/CuboidDeformable", cfg_cuboid_deformable,
                                translation=(0.15, 0.0, 2.0))

    # 7. 加载一个外部 USD 文件（桌子模型）
    cfg = sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Props/Mounts/SeattleLabTable/table_instanceable.usd"
    )
    cfg.func("/World/Objects/Table", cfg, translation=(0.0, 0.0, 1.05))


def main():
    """脚本主入口"""
    # 初始化仿真上下文，设置时间步长 dt=0.01、运行设备（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建新的“空”场景
    # 设置主相机视角：位置 + 目标方向
    sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

    # 调用函数往场景里添加对象
    design_scene()

    # 重置场景，开始仿真前清空内部状态
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 进入仿真循环：只要应用未关闭，就不断执行 sim.step()
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭仿真应用

```

**关键解读**：

---
*1. `GroundPlaneCfg` 可用的参数

`GroundPlaneCfg` 的构造函数通常接收以下可选参数（以 Isaac Lab vX.X API 为准）：

|参数名|类型|说明|默认值|
|---|---|---|---|
|`size`|`tuple[float, float]`|地面平面的 X、Y 方向尺寸|`(10.0, 10.0)`|
|`height`|`float`|地面平面在 Z 轴上的高度|`0.0`|
|`static`|`bool`|是否注册为静态刚体（不参与动力学）|`True`|
|`collision_props`|`CollisionPropertiesCfg`|碰撞属性（摩擦系数、弹性系数等）|`默认值`|
|`visual_material`|`PreviewSurfaceCfg`|可视化材质（漫反射颜色、纹理等）|`默认灰色`|

> **提示**：如果你需要让地面也可变形或带特殊物理属性，可传入相应的 `deformable_props`、`mass_props` 等。

---

*2. 为 USD 模型指定可变形材质

是的，`UsdFileCfg`（以及其它 prim 配置类，比如 `MeshCuboidCfg`、`SphereCfg` 等）都支持接收可变形（deformable）相关的配置：

- **`deformable_props`**：类型为 `DeformableBodyPropertiesCfg`，开启并设置网格变形参数
    
- **`physics_material`**：类型为 `DeformableBodyMaterialCfg`，定义可变形材质的物理特性
    
- **`mass_props`**：类型为 `MassPropertiesCfg`，除了 `mass` 之外，可以指定 `density`
    

---

### 3. 设置密度（Density）或其它物理属性

`MassPropertiesCfg` 除了 `mass`，还接收 `density`。如果同时给出两者，通常以 `mass` 为准；只给 `density` 时，根据模型体积自动计算质量。

其它常见可设置的属性还有：

- 碰撞属性（`CollisionPropertiesCfg`）：`friction`、`restitution`、`collision_group` 等
    
- 刚体属性（`RigidBodyPropertiesCfg`）：`is_kinematic`、`enable_ccd`（连续碰撞检测）等
    
- 可变形属性（`DeformableBodyPropertiesCfg`）：`solver_iterations`、`enable_self_collision` 等

==代码示例：==
```python
import argparse
from isaaclab.app import AppLauncher
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

def design_scene():
    # 在 /World/Objects 下创建根节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 示例 USD 模型路径
    usd_path = f"{ISAAC_NUCLEUS_DIR}/Props/Models/MyModel/my_model.usd"

    # 为 USD 模型配置各种可选属性
    cfg_model = sim_utils.UsdFileCfg(
        # 模型文件路径（必填）
        usd_path=usd_path,

        # —————————————————————————————————————————————————————————————
        # 物理／动力学相关：
        # —————————————————————————————————————————————————————————————

        # 1. 刚体属性（开启刚体模拟，或设置为运动学 kinematic）
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            is_kinematic=False,     # 是否运动学
            enable_ccd=True,        # 连续碰撞检测
            solver_position_iters=4, # 位置求解迭代次数
            solver_velocity_iters=1, # 速度求解迭代次数
        ),

        # 2. 质量属性（直接指定质量，或指定 density 由体积自动算质量）
        mass_props=sim_utils.MassPropertiesCfg(
            mass=2.5,       # 质量，单位 kg
            # density=500.0 # 密度，单位 kg/m³（与 mass 二选一即可）
        ),

        # 3. 碰撞属性（摩擦、弹性、分组等）
        collision_props=sim_utils.CollisionPropertiesCfg(
            friction=0.7,         # 摩擦系数
            restitution=0.2,      # 弹性系数
            collision_group=1,    # 碰撞分组
            collision_filter=0xFF # 过滤掩码
        ),

        # 4. 可变形物体属性（如果想用柔体模拟）
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(
            enable_self_collision=False,
            solver_iterations=15,
            damping_coefficient=0.1,
        ),

        # —————————————————————————————————————————————————————————————
        # 材质／渲染相关：
        # —————————————————————————————————————————————————————————————

        # 5. 预览表面材质（漫反射、镜面、纹理贴图等）
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.8, 0.1, 0.1),
            roughness=0.5,
            metallic=0.0,
            # base_color_texture="Textures/my_diffuse.png"
        ),

        # 6. 可变形体专用物理材质（仅在 deformable_props 有值时生效）
        physics_material=sim_utils.DeformableBodyMaterialCfg(
            youngs_modulus=2e6,
            poissons_ratio=0.35,
            # enable_damping=True,
            # enable_fiber=True
        ),

        # 7. 可选：可视化调试线框
        debug_draw=True,
    )

    # 将配置挂载到场景中的指定路径，并附带 transform
    cfg_model.func(
        "/World/Objects/MyDeformableModel",
        cfg_model,
        translation=(0.0, 0.0, 1.0),
        orientation=(0, 0, 0, 1),
        scale=(1.0, 1.0, 1.0)
    )

def main():
    # 启动 Isaac Lab 应用
    parser = argparse.ArgumentParser()
    AppLauncher.add_app_launcher_args(parser)
    args = parser.parse_args()
    app = AppLauncher(args).app

    # 初始化仿真
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view([2, -2, 2], [0, 0, 1])

    # 设计场景并挂载模型
    design_scene()

    # 重置并开始仿真
    sim.reset()
    while app.is_running():
        sim.step()
    app.close()

if __name__ == "__main__":
    main()

```

---

*4. `.func()` 方法的作用

每个 `*Cfg` 对象（例如 `GroundPlaneCfg`、`ConeCfg`、`UsdFileCfg`）上都有一个 `.func(path, cfg, **kwargs)` 方法，这是一个统一的“挂载”接口，它会：

1. 在场景里 **创建或查找** 指定的 prim（`path`）。
    
2. **应用该配置**（`cfg`）到这个 prim 上，比如设置几何形状、物理属性、材质。
    
3. 接受额外关键字参数，如 `translation=(x,y,z)`、`orientation=(qx,qy,qz,qw)`、`scale=(sx,sy,sz)` 等，用于直接指定 transform。

---


# 深入了解AppLauncher

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
这个脚本演示了如何通过 AppLauncher 启动并运行 Isaac Sim

.. code-block:: bash

    # 用法示例
    ./isaaclab.sh -p scripts/tutorials/00_sim/launch_app.py

"""

"""请先启动 Isaac Sim Simulator 后，再运行此脚本"""

import argparse
from isaaclab.app import AppLauncher

# ===== 1. 创建命令行参数解析器，用于接收脚本启动参数 =====
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
# 自定义参数：长方体边长
parser.add_argument(
    "--size", type=float, default=1.0,
    help="Side-length of cuboid"
)
# 自定义参数：视口及截图宽度
parser.add_argument(
    "--width", type=int, default=1280,
    help="Width of the viewport and generated images. Defaults to 1280"
)
# 自定义参数：视口及截图高度
parser.add_argument(
    "--height", type=int, default=720,
    help="Height of the viewport and generated images. Defaults to 720"
)

# ===== 2. 将 AppLauncher 自带的命令行参数（如 --headless, --device）添加进来 =====
AppLauncher.add_app_launcher_args(parser)
# 解析所有命令行参数
args_cli = parser.parse_args()

# ===== 3. 使用解析好的参数创建并启动 Omniverse Isaac Sim 应用 =====
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取 SimulationApp 实例

"""下面开始核心仿真逻辑"""
import isaaclab.sim as sim_utils

def design_scene():
    """设计场景：添加地面、光源和长方体"""
    # 1) GroundPlaneCfg：生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # func() 创建 prim 并应用配置
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2) DistantLightCfg：生成远处光源
    cfg_light = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光照强度
        color=(0.75, 0.75, 0.75),         # 灰白色
    )
    cfg_light.func(
        "/World/lightDistant", cfg_light,
        translation=(1, 0, 10)            # 放置在 (1,0,10)
    )

    # 3) CuboidCfg：生成长方体
    cfg_cuboid = sim_utils.CuboidCfg(
        size=[args_cli.size] * 3,         # XYZ 三维方向尺寸均为 --size
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 1.0, 1.0)  # 白色材质
        ),
    )
    # 将长方体放置到合适高度 (size/2)
    cfg_cuboid.func(
        "/World/Object", cfg_cuboid,
        translation=(0.0, 0.0, args_cli.size / 2)
    )


def main():
    """脚本主程序入口"""
    # 4) 初始化仿真上下文：时间步 dt=0.01，运行设备由 --device 决定
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建空场景

    # 5) 设置主相机视角：位置与朝向
    sim.set_camera_view([
        2.0, 0.0, 2.5    # 相机位置 (X,Y,Z)
    ], [
        -0.5, 0.0, 0.5   # 相机朝向向量
    ])

    # 6) 设计并填充场景
    design_scene()

    # 7) 重置仿真：清空内部状态并开始运行
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 8) 循环执行仿真步
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭 Isaac Sim 应用

```


---

### 1. 接入并解析自定义与 AppLauncher 参数

```python
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
parser.add_argument("--size", type=float, default=1.0, help="Side-length of cuboid")
parser.add_argument("--width", type=int, default=1280, help="Width of the viewport …")
parser.add_argument("--height", type=int, default=720, help="Height of the viewport …")

# 将 AppLauncher 本身所需的参数（如 --headless, --device, --renderer 等）注入到同一解析器中
AppLauncher.add_app_launcher_args(parser)
args_cli = parser.parse_args()
```

- **目的**：把你自己脚本的参数（`--size`, `--width`, `--height`）和 `AppLauncher` 所依赖的底层渲染/仿真参数合并在一起，用同一个命令行接口一次性传递给脚本。
    
- **好处**：无需区分两套参数，启动时只需一行命令即可同时控制应用层和仿真层的行为。
    

---

### 2. 通过 `AppLauncher` 启动 Isaac Sim

```python
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app
```

- **`AppLauncher(args_cli)`**：内部会根据命令行参数启动 Omniverse Kit 应用，加载 Isaac Sim 模块，并返回一个封装好的 `Application` 对象。
    
- **`app_launcher.app`**：这是对底层 `SimulationApp` 的引用，用于之后查询“应用是否还在运行”、关闭应用等操作。
    

---

### 3. 设计场景逻辑与 `.func()` 用法

```python
def design_scene():
    cfg_ground = sim_utils.GroundPlaneCfg()
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    cfg_light = sim_utils.DistantLightCfg(intensity=3000.0, color=(0.75,0.75,0.75))
    cfg_light.func("/World/lightDistant", cfg_light, translation=(1,0,10))

    cfg_cuboid = sim_utils.CuboidCfg(size=[args_cli.size]*3, visual_material=...)
    cfg_cuboid.func("/World/Object", cfg_cuboid, translation=(0,0,args_cli.size/2))
```

- **各 `*Cfg` 类**：负责持有一系列参数（几何、物理、材质等）。
    
- **`.func(path, cfg, **kwargs)`**：统一接口，用于
    
    1. 在 USD 场景中创建（或定位）指定路径下的 prim；
        
    2. 将 `cfg` 中的所有配置应用到该 prim；
        
    3. 额外接收 `translation`、`orientation`、`scale` 等 transform 参数。
        

---

### 4. 仿真上下文初始化与主循环

```python
sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
sim = sim_utils.SimulationContext(sim_cfg)
sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

design_scene()
sim.reset()
while simulation_app.is_running():
    sim.step()
```

- **`SimulationCfg`**：封装了物理仿真的全局设置（时间步长、执行设备等）。
    
- **`SimulationContext`**：在内部构建和管理物理世界状态、时钟、渲染循环。
    
- **`sim.set_camera_view(pos, target)`**：一次性设置相机位置与朝向。
    
- **`sim.reset()`**：启动前重置场景，确保所有 prim、物理状态回到初始。
    
- **循环调用 `sim.step()`**：在每帧里推进一次物理与渲染。
    

---

#### 小结

- **核心就在于**：用 `AppLauncher` 统一管理底层应用的启动和参数，再通过 `sim_utils` 的高阶配置类和 `.func()` 方法快速构建场景，最后在 `SimulationContext` 中集中驱动仿真循环。
    
- 这种分层结构让“启动”、“配置场景”、“运行仿真”三者职责明确，代码既灵活又易于维护。




----

# 将新机器人添加到 Isaac Lab
[将新机器人添加到 Isaac Lab — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/01_assets/add_new_robot.html)

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import argparse
from isaaclab.app import AppLauncher
import numpy as np
import torch
import isaaclab.sim as sim_utils
# 导入 ImplicitActuatorCfg：用于创建显式阻抗执行器，控制关节弹性和阻尼特性
from isaaclab.actuators import ImplicitActuatorCfg
# 资产基础配置，用于定义地面、灯光、机器人等
from isaaclab.assets import AssetBaseCfg
# ArticulationCfg：用于定义可动关节及其物理属性
from isaaclab.assets.articulation import ArticulationCfg
# 交互式场景及其配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg
# Isaac Nucleus 资源路径常量，用于加载 USD 模型
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

# ===== 1. 命令行参数配置 =====
# 创建 ArgumentParser 实例用于解析脚本运行时的参数
parser = argparse.ArgumentParser(
    description="此脚本演示如何在 Isaac Lab 环境中添加自定义机器人。"
)
# 用户可指定并行仿真环境数量，默认为 1
parser.add_argument(
    "--num_envs", type=int, default=1,
    help="要创建的并行仿真环境数量。"
)
# 将 AppLauncher 支持的标准参数（如 --headless, --device）加入解析器
AppLauncher.add_app_launcher_args(parser)
# 解析命令行输入，得到 args_cli 对象
args_cli = parser.parse_args()

# ===== 2. 启动 Omniverse Isaac Sim 应用 =====
# 通过 AppLauncher 根据解析参数启动 SimulationApp
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取底层 SimulationApp 实例

# ===== 3. 定义两个自定义机器人配置：JETBOT 和 DOFBOT =====
# 3.1 Jetbot：简单驱动机器人，所有关节使用阻抗执行器
JETBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Jetbot/jetbot.usd"
    ),
    actuators={
        # 针对名称匹配正则 ".*" 的所有关节，使用默认阻尼和刚度
        "wheel_acts": ImplicitActuatorCfg(
            joint_names_expr=[".*"],  # 匹配所有关节名称
            damping=None,               # None 表示使用物理默认阻尼
            stiffness=None              # None 表示使用物理默认刚度
        )
    },
)

# 3.2 Dofbot：6-DOF 机械臂，细化物理属性、自碰撞和执行器参数
DOFBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Dofbot/dofbot.usd",
        # 定义刚体属性：是否受重力影响和最大分离速度
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            max_depenetration_velocity=5.0,
        ),
        # 定义关节根节点属性：开启自碰撞及迭代求解次数
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=True,
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=0
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        # 初始关节角位置（rad）
        joint_pos={
            "joint1": 0.0,
            "joint2": 0.0,
            "joint3": 0.0,
            "joint4": 0.0,
        },
        # 机器人整体初始位置偏移（x,y,z）
        pos=(0.25, -0.25, 0.0),
    ),
    actuators={
        # 前两个关节阻抗执行器，可设置力矩和速度限制
        "front_joints": ImplicitActuatorCfg(
            joint_names_expr=["joint[1-2]"],
            effort_limit_sim=100.0,    # 最大扭矩 (Nm)
            velocity_limit_sim=100.0,  # 最大速度 (rad/s)
            stiffness=10000.0,         # 刚度 (N·m/rad)
            damping=100.0,             # 阻尼 (N·m·s/rad)
        ),
        # 独立配置 joint3 和 joint4
        "joint3_act": ImplicitActuatorCfg(
            joint_names_expr=["joint3"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
        "joint4_act": ImplicitActuatorCfg(
            joint_names_expr=["joint4"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
    },
)

# ===== 4. 自定义交互式场景配置 =====
class NewRobotsSceneCfg(InteractiveSceneCfg):
    """场景配置：包含地面、全景光照和机器人实例。"""
    # 地面平面，作为机器人行走参考
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",
        spawn=sim_utils.GroundPlaneCfg()
    )
    # 全景半球光，用于模拟环境光照
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,          # 光照强度
            color=(0.75, 0.75, 0.75)     # 灯光颜色 (RGB)
        )
    )
    # 将机器人配置绑定到命名空间，支持多环境实例化
    Jetbot = JETBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Jetbot")
    Dofbot = DOFBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Dofbot")

# ===== 5. 仿真主循环逻辑 =====
def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """执行仿真步进、机器人控制和周期性重置。"""
    # 获取物理仿真步长 (秒)
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0  # 累计仿真时间
    count = 0       # 计步器，用于定时动作切换和重置

    # 当窗口未关闭时持续运行
    while simulation_app.is_running():
        # 每隔 500 步重置机器人到初始状态
        if count % 500 == 0:
            count = 0
            # 克隆默认根部状态，并根据环境原点偏移
            root_jetbot = scene["Jetbot"].data.default_root_state.clone()
            root_jetbot[:, :3] += scene.env_origins
            root_dofbot = scene["Dofbot"].data.default_root_state.clone()
            root_dofbot[:, :3] += scene.env_origins

            # 将位置、姿态和速度写回仿真
            scene["Jetbot"].write_root_pose_to_sim(root_jetbot[:, :7])
            scene["Jetbot"].write_root_velocity_to_sim(root_jetbot[:, 7:])
            scene["Dofbot"].write_root_pose_to_sim(root_dofbot[:, :7])
            scene["Dofbot"].write_root_velocity_to_sim(root_dofbot[:, 7:])

            # 重置关节位置和速度
            jp, jv = (
                scene["Jetbot"].data.default_joint_pos.clone(),
                scene["Jetbot"].data.default_joint_vel.clone(),
            )
            scene["Jetbot"].write_joint_state_to_sim(jp, jv)
            jp, jv = (
                scene["Dofbot"].data.default_joint_pos.clone(),
                scene["Dofbot"].data.default_joint_vel.clone(),
            )
            scene["Dofbot"].write_joint_state_to_sim(jp, jv)

            scene.reset()  # 场景全局重置，多环境同时作用
            print("[INFO]: 重置 Jetbot 和 Dofbot 状态...")

        # ===== 机器人控制逻辑 =====
        # Jetbot: 直行与转向交替，每 100 步内前 75 步直行，后 25 步转弯
        if count % 100 < 75:
            action = torch.Tensor([[10.0, 10.0]])  # 左右轮相同速率，直行
        else:
            action = torch.Tensor([[5.0, -5.0]])   # 反向差速，原地转动
        scene["Jetbot"].set_joint_velocity_target(action)

        # Dofbot: 四个关节做正弦波振动，幅度 0.25 rad，频率 0.5 Hz
        wave_action = scene["Dofbot"].data.default_joint_pos
        wave_action[:, 0:4] = 0.25 * np.sin(2 * np.pi * 0.5 * sim_time)
        scene["Dofbot"].set_joint_position_target(wave_action)

        # 写入所有命令并推进仿真一步
        scene.write_data_to_sim()
        sim.step()
        sim_time += sim_dt
        count += 1
        # 更新场景渲染和交互
        scene.update(sim_dt)

# ===== 6. 程序入口 =====
def main():
    """脚本入口：初始化仿真上下文和场景，并启动循环。"""
    # 构造仿真配置，包括设备类型（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)

    # 可选：设置默认摄像机视角 (位置, 朝向)
    sim.set_camera_view([3.5, 0.0, 3.2], [0.0, 0.0, 0.5])

    # 构建场景配置，指定环境数量和间距
    scene_cfg = NewRobotsSceneCfg(args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)

    sim.reset()  # 初始化仿真状态
    print("[INFO]: 设置完成，开始运行仿真...")
    run_simulator(sim, scene)

if __name__ == "__main__":
    main()
    # 退出时关闭应用窗口，释放资源
    simulation_app.close()

```

==关键解读==：

## 1. ImplicitActuatorCfg vs ArticulationCfg

- **ArticulationCfg**  
    这是对“树状关节（Articulation）”整体的配置，通常包括：
    
    - 铰链／关节数量与拓扑
        
    - 各关节的物理属性（质量、惯量、摩擦、初始位置等）
        
    - 刚体之间的连接方式（铰链、滑动、球铰）
        
    - 关节限制（转动角度／线性位移范围）
        
    - 动力学求解器参数（比如 solver iteration count）  
        简言之，`ArticulationCfg` 定义了一个多关节机器人或机械臂的物理骨架与动力学属性。
        
- **ImplicitActuatorCfg**  
    这是针对“隐式执行器（Implicit Actuator）”的配置。隐式执行器通常指在动力学求解过程中，将执行器力（torque/force）以“隐式积分”方式加入求解器，以提升数值稳定性。它包含：
    
    - 执行器类型（位置控制、力控制、阻抗控制等）
        
    - 控制参数（刚度 `stiffness`、阻尼 `damping`、最大力矩等）
        
    - 目标命令格式（位置目标、速度目标或力目标）  
        简单说，`ImplicitActuatorCfg` 定义了如何把高层控制命令转换为关节／驱动力，并以隐式方式与物理引擎耦合。
        

---

## 2. 阻抗执行器（Impedance Actuator）是什么？

阻抗控制（Impedance Control）是一种把机器人关节或末端执行器当作弹簧-阻尼系统来控制的方法。与“纯位置控制”不同，阻抗执行器会根据：

- 目标位置偏差 → 产生弹性力（`F = K (x_target − x_actual)`）
    
- 速度差异 → 产生阻尼力（`F = D (v_target − v_actual)`）  
    这样，当执行器和环境发生接触时，它能以更自然的“软”响应来吸收冲击，增强交互安全性与稳定性。
    

在隐式执行器中，阻抗模型的力直接融入物理求解器矩阵，允许大步长且更稳定地模拟高刚度情形。

---

## 3. 将机器人绑定到实例空间（instance space）是什么意思？

在多场景或多并发仿真中，“实例空间”指一组“相同模型”的并行副本。

- 你把一个机器人模型（URDF／USD）实例化多份，每份称为一个“实例”。
    
- “绑定到实例空间”即把这具机器人物理骨架、状态跟踪、碰撞体等关联到某个实例 ID，使后续的状态更新、碰撞检测、渲染等，都在这个命名空间里并行进行。
    
- 这样你就可以一次性批量加载 N 个机器人，利用 GPU 并行加速物理与感知。
    

---

## 4. `def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):` 这里是什么？

这里是一个函数定义，接收两个参数：

- `sim: sim_utils.SimulationContext`：封装物理引擎、时间步长、步进函数等。
    
- `scene: InteractiveScene`：封装场景资源、渲染相机、交互事件等。
    

它是你的控制脚本里向引擎传入“仿真上下文”与“场景对象”，然后在函数内部启动主循环。

---

## 5. `root_jetbot = scene["Jetbot"].data.default_root_state.clone()` 是做什么用的？

- `scene["Jetbot"]`：通过名字从场景中取到名为 “Jetbot” 的实体（Instance）。
    
- `.data.default_root_state`：这是这具机器人的“默认根状态”（一般包括全局位置、朝向、各关节初始角度）。
    
- `.clone()`：复制一份这个状态副本，避免直接修改原始模板。
    

**用途**：拿到该机器人从零加载时的基准状态，之后可以在仿真开始前或复位时，直接把它设回这份克隆状态。

---
