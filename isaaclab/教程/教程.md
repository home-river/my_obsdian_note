

# 创建空舞台

```python
"""这个脚本演示了如何在 Isaac Sim 中创建一个简单的场景（舞台）。

.. code-block:: bash

    # 使用方法
    ./isaaclab.sh -p scripts/tutorials/00_sim/create_empty.py

"""

"""请先启动 Isaac Sim 模拟器。"""

import argparse  # 导入命令行参数解析模块

from isaaclab.app import AppLauncher  # 从 isaaclab.app 中导入 AppLauncher 类

# 创建命令行参数解析器
parser = argparse.ArgumentParser(description="创建空舞台的教程。")
# 将 AppLauncher 的命令行参数添加到解析器中
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
# 获取模拟应用实例
simulation_app = app_launcher.app

"""下面的代码开始主体逻辑。"""

from isaaclab.sim import SimulationCfg, SimulationContext  # 导入模拟配置和上下文类


def main():
    """主函数入口。"""

    # 初始化模拟配置，设置时间步长 dt
    sim_cfg = SimulationCfg(dt=0.01)
    # 创建模拟上下文
    sim = SimulationContext(sim_cfg)
    # 设置主摄像机位置和观察目标
    sim.set_camera_view([2.5, 2.5, 2.5], [0.0, 0.0, 0.0])

    # 重置模拟
    sim.reset()
    # 模拟设置完成提示
    print("[INFO]: 设置完成...")

    # 开始物理模拟循环
    while simulation_app.is_running():
        # 执行一步模拟
        sim.step()


# 如果脚本作为主程序执行，则运行 main 函数并关闭应用
if __name__ == "__main__":
    # 调用主函数
    main()
    # 关闭模拟应用
    simulation_app.close()

```


`SimulationCfg` 的构造函数可以接受多个参数。以下是一些常见的配置参数（具体可参考 Isaac Lab 文档或源码）：

- `dt`：仿真时间步长（秒），即每次 `step()` 前进的模型时间。
    
- `gravity`：重力向量，通常是一个 3 元组或列表，例如 `[0, 0, -9.81]`。
    
- `use_gpu`：布尔值，是否在 GPU 上运行物理仿真。
    
- `up_axis`：场景的上方向，可以是字符串 `"Z"` 或者 `"Y"`，决定重力方向等。
    
- `solver_iterations`：物理求解器迭代次数，影响模拟精度与速度。
    
- `substeps`：每个渲染帧内进行的物理子步数量，用于更精细的物理计算。
    
- `enable_flatcache`：布尔值，是否开启 Omniverse 的扁平缓存加速。
    
- 更多高级选项，如碰撞参数、渲染选项等。
    

示例：

```python
sim_cfg = SimulationCfg(
    dt=0.01,
    gravity=[0.0, 0.0, -9.81],
    use_gpu=True,
    up_axis="Z",
    solver_iterations=10,
    substeps=2
)
```


```python
sim = SimulationContext(sim_cfg)
```

的作用就是根据你传入的配置（`sim_cfg`）初始化并创建一个新的、“空”的模拟环境（舞台）。此时，所有的模拟状态、实体、事件队列等都还没被填充或启动，就像一个刚搭建好的戏台，还没有上演员和道具。后续你可以往这个 `sim` 对象里添加参数、注册实体、推进时间步等操作，都将在这个空白舞台上进行。


---

# 为场景添加基本物体
[生成基本物体到场景中 — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/00_sim/spawn_prims.html)


```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""脚本演示了怎么往stage添加基本物体.

.. code-block:: bash

    # 用法
    ./isaaclab.sh -p scripts/tutorials/00_sim/spawn_prims.py

"""

"""Launch Isaac Sim Simulator first."""

import argparse
from isaaclab.app import AppLauncher

# 创建命令行参数解析器，用于接收脚本运行时的参数
parser = argparse.ArgumentParser(description="Tutorial on spawning prims into the scene.")
# 向解析器添加 Isaac Lab 应用启动器的专用参数（如 --headless, --device 等）
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()
# 根据解析到的 CLI 参数创建并启动 Omniverse Isaac Sim 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取启动后的应用实例

"""后续所有逻辑都在 Isaac Sim 应用中执行"""
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR


def design_scene():
    """在场景中生成地面、光源、基本原语和 USD 模型等对象"""
    # 1. 生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # 调用 config 的 func 方法，将地面 prim 添加到 /World/defaultGroundPlane
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2. 生成远处光源（Distant Light）
    cfg_light_distant = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光源强度
        color=(0.75, 0.75, 0.75),         # 灰白色光
    )
    # 将远处光源放置在世界坐标 (1,0,10)
    cfg_light_distant.func(
        "/World/lightDistant", cfg_light_distant,
        translation=(1, 0, 10)
    )

    # 3. 在 /World/ 下创建一个空的 Xform prim，用作后续所有对象的父节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 4. 生成两个红色实心圆锥
    cfg_cone = sim_utils.ConeCfg(
        radius=0.15,                       # 半径
        height=0.5,                        # 高度
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 0.0, 0.0)  # 红色材质
        ),
    )
    # 将圆锥放置在不同位置
    cfg_cone.func("/World/Objects/Cone1", 
				  cfg_cone,
				  translation=(-1.0, 1.0, 1.0))
    cfg_cone.func("/World/Objects/Cone2", 
			      cfg_cone,
				  translation=(-1.0, -1.0, 1.0))

    # 5. 生成一个带物理属性（刚体）的绿色圆锥
    cfg_cone_rigid = sim_utils.ConeCfg(
        radius=0.15,
        height=0.5,
        rigid_props=sim_utils.RigidBodyPropertiesCfg(),         # 刚体属性
        mass_props=sim_utils.MassPropertiesCfg(mass=1.0),      # 质量属性
        collision_props=sim_utils.CollisionPropertiesCfg(),    # 碰撞属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 1.0, 0.0)  # 绿色材质
        ),
    )
    # 设置位置和旋转四元数
    cfg_cone_rigid.func(
        "/World/Objects/ConeRigid", cfg_cone_rigid,
        translation=(-0.2, 0.0, 2.0),
        orientation=(0.5, 0.0, 0.5, 0.0)
    )

    # 6. 生成一个可变形的蓝色长方体
    cfg_cuboid_deformable = sim_utils.MeshCuboidCfg(
        size=(0.2, 0.5, 0.2),                                  # 尺寸 (X, Y, Z)
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(),  # 可变形物体属性
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.0, 0.0, 1.0)                      # 蓝色材质
        ),
        physics_material=sim_utils.DeformableBodyMaterialCfg(),  # 可变形材质属性
    )
    cfg_cuboid_deformable.func("/World/Objects/CuboidDeformable", cfg_cuboid_deformable,
                                translation=(0.15, 0.0, 2.0))

    # 7. 加载一个外部 USD 文件（桌子模型）
    cfg = sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Props/Mounts/SeattleLabTable/table_instanceable.usd"
    )
    cfg.func("/World/Objects/Table", cfg, translation=(0.0, 0.0, 1.05))


def main():
    """脚本主入口"""
    # 初始化仿真上下文，设置时间步长 dt=0.01、运行设备（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建新的“空”场景
    # 设置主相机视角：位置 + 目标方向
    sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

    # 调用函数往场景里添加对象
    design_scene()

    # 重置场景，开始仿真前清空内部状态
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 进入仿真循环：只要应用未关闭，就不断执行 sim.step()
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭仿真应用

```

**关键解读**：

---
*1. `GroundPlaneCfg` 可用的参数

`GroundPlaneCfg` 的构造函数通常接收以下可选参数（以 Isaac Lab vX.X API 为准）：

|参数名|类型|说明|默认值|
|---|---|---|---|
|`size`|`tuple[float, float]`|地面平面的 X、Y 方向尺寸|`(10.0, 10.0)`|
|`height`|`float`|地面平面在 Z 轴上的高度|`0.0`|
|`static`|`bool`|是否注册为静态刚体（不参与动力学）|`True`|
|`collision_props`|`CollisionPropertiesCfg`|碰撞属性（摩擦系数、弹性系数等）|`默认值`|
|`visual_material`|`PreviewSurfaceCfg`|可视化材质（漫反射颜色、纹理等）|`默认灰色`|

> **提示**：如果你需要让地面也可变形或带特殊物理属性，可传入相应的 `deformable_props`、`mass_props` 等。

---

*2. 为 USD 模型指定可变形材质

是的，`UsdFileCfg`（以及其它 prim 配置类，比如 `MeshCuboidCfg`、`SphereCfg` 等）都支持接收可变形（deformable）相关的配置：

- **`deformable_props`**：类型为 `DeformableBodyPropertiesCfg`，开启并设置网格变形参数
    
- **`physics_material`**：类型为 `DeformableBodyMaterialCfg`，定义可变形材质的物理特性
    
- **`mass_props`**：类型为 `MassPropertiesCfg`，除了 `mass` 之外，可以指定 `density`
    

---

### 3. 设置密度（Density）或其它物理属性

`MassPropertiesCfg` 除了 `mass`，还接收 `density`。如果同时给出两者，通常以 `mass` 为准；只给 `density` 时，根据模型体积自动计算质量。

其它常见可设置的属性还有：

- 碰撞属性（`CollisionPropertiesCfg`）：`friction`、`restitution`、`collision_group` 等
    
- 刚体属性（`RigidBodyPropertiesCfg`）：`is_kinematic`、`enable_ccd`（连续碰撞检测）等
    
- 可变形属性（`DeformableBodyPropertiesCfg`）：`solver_iterations`、`enable_self_collision` 等

==代码示例：==
```python
import argparse
from isaaclab.app import AppLauncher
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

def design_scene():
    # 在 /World/Objects 下创建根节点
    prim_utils.create_prim("/World/Objects", "Xform")

    # 示例 USD 模型路径
    usd_path = f"{ISAAC_NUCLEUS_DIR}/Props/Models/MyModel/my_model.usd"

    # 为 USD 模型配置各种可选属性
    cfg_model = sim_utils.UsdFileCfg(
        # 模型文件路径（必填）
        usd_path=usd_path,

        # —————————————————————————————————————————————————————————————
        # 物理／动力学相关：
        # —————————————————————————————————————————————————————————————

        # 1. 刚体属性（开启刚体模拟，或设置为运动学 kinematic）
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            is_kinematic=False,     # 是否运动学
            enable_ccd=True,        # 连续碰撞检测
            solver_position_iters=4, # 位置求解迭代次数
            solver_velocity_iters=1, # 速度求解迭代次数
        ),

        # 2. 质量属性（直接指定质量，或指定 density 由体积自动算质量）
        mass_props=sim_utils.MassPropertiesCfg(
            mass=2.5,       # 质量，单位 kg
            # density=500.0 # 密度，单位 kg/m³（与 mass 二选一即可）
        ),

        # 3. 碰撞属性（摩擦、弹性、分组等）
        collision_props=sim_utils.CollisionPropertiesCfg(
            friction=0.7,         # 摩擦系数
            restitution=0.2,      # 弹性系数
            collision_group=1,    # 碰撞分组
            collision_filter=0xFF # 过滤掩码
        ),

        # 4. 可变形物体属性（如果想用柔体模拟）
        deformable_props=sim_utils.DeformableBodyPropertiesCfg(
            enable_self_collision=False,
            solver_iterations=15,
            damping_coefficient=0.1,
        ),

        # —————————————————————————————————————————————————————————————
        # 材质／渲染相关：
        # —————————————————————————————————————————————————————————————

        # 5. 预览表面材质（漫反射、镜面、纹理贴图等）
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(0.8, 0.1, 0.1),
            roughness=0.5,
            metallic=0.0,
            # base_color_texture="Textures/my_diffuse.png"
        ),

        # 6. 可变形体专用物理材质（仅在 deformable_props 有值时生效）
        physics_material=sim_utils.DeformableBodyMaterialCfg(
            youngs_modulus=2e6,
            poissons_ratio=0.35,
            # enable_damping=True,
            # enable_fiber=True
        ),

        # 7. 可选：可视化调试线框
        debug_draw=True,
    )

    # 将配置挂载到场景中的指定路径，并附带 transform
    cfg_model.func(
        "/World/Objects/MyDeformableModel",
        cfg_model,
        translation=(0.0, 0.0, 1.0),
        orientation=(0, 0, 0, 1),
        scale=(1.0, 1.0, 1.0)
    )

def main():
    # 启动 Isaac Lab 应用
    parser = argparse.ArgumentParser()
    AppLauncher.add_app_launcher_args(parser)
    args = parser.parse_args()
    app = AppLauncher(args).app

    # 初始化仿真
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args.device)
    sim = sim_utils.SimulationContext(sim_cfg)
    sim.set_camera_view([2, -2, 2], [0, 0, 1])

    # 设计场景并挂载模型
    design_scene()

    # 重置并开始仿真
    sim.reset()
    while app.is_running():
        sim.step()
    app.close()

if __name__ == "__main__":
    main()

```

---

*4. `.func()` 方法的作用

每个 `*Cfg` 对象（例如 `GroundPlaneCfg`、`ConeCfg`、`UsdFileCfg`）上都有一个 `.func(path, cfg, **kwargs)` 方法，这是一个统一的“挂载”接口，它会：

1. 在场景里 **创建或查找** 指定的 prim（`path`）。
    
2. **应用该配置**（`cfg`）到这个 prim 上，比如设置几何形状、物理属性、材质。
    
3. 接受额外关键字参数，如 `translation=(x,y,z)`、`orientation=(qx,qy,qz,qw)`、`scale=(sx,sy,sz)` 等，用于直接指定 transform。

---


# 深入了解AppLauncher

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
这个脚本演示了如何通过 AppLauncher 启动并运行 Isaac Sim

.. code-block:: bash

    # 用法示例
    ./isaaclab.sh -p scripts/tutorials/00_sim/launch_app.py

"""

"""请先启动 Isaac Sim Simulator 后，再运行此脚本"""

import argparse
from isaaclab.app import AppLauncher

# ===== 1. 创建命令行参数解析器，用于接收脚本启动参数 =====
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
# 自定义参数：长方体边长
parser.add_argument(
    "--size", type=float, default=1.0,
    help="Side-length of cuboid"
)
# 自定义参数：视口及截图宽度
parser.add_argument(
    "--width", type=int, default=1280,
    help="Width of the viewport and generated images. Defaults to 1280"
)
# 自定义参数：视口及截图高度
parser.add_argument(
    "--height", type=int, default=720,
    help="Height of the viewport and generated images. Defaults to 720"
)

# ===== 2. 将 AppLauncher 自带的命令行参数（如 --headless, --device）添加进来 =====
AppLauncher.add_app_launcher_args(parser)
# 解析所有命令行参数
args_cli = parser.parse_args()

# ===== 3. 使用解析好的参数创建并启动 Omniverse Isaac Sim 应用 =====
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取 SimulationApp 实例

"""下面开始核心仿真逻辑"""
import isaaclab.sim as sim_utils

def design_scene():
    """设计场景：添加地面、光源和长方体"""
    # 1) GroundPlaneCfg：生成地面平面
    cfg_ground = sim_utils.GroundPlaneCfg()
    # func() 创建 prim 并应用配置
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    # 2) DistantLightCfg：生成远处光源
    cfg_light = sim_utils.DistantLightCfg(
        intensity=3000.0,                 # 光照强度
        color=(0.75, 0.75, 0.75),         # 灰白色
    )
    cfg_light.func(
        "/World/lightDistant", cfg_light,
        translation=(1, 0, 10)            # 放置在 (1,0,10)
    )

    # 3) CuboidCfg：生成长方体
    cfg_cuboid = sim_utils.CuboidCfg(
        size=[args_cli.size] * 3,         # XYZ 三维方向尺寸均为 --size
        visual_material=sim_utils.PreviewSurfaceCfg(
            diffuse_color=(1.0, 1.0, 1.0)  # 白色材质
        ),
    )
    # 将长方体放置到合适高度 (size/2)
    cfg_cuboid.func(
        "/World/Object", cfg_cuboid,
        translation=(0.0, 0.0, args_cli.size / 2)
    )


def main():
    """脚本主程序入口"""
    # 4) 初始化仿真上下文：时间步 dt=0.01，运行设备由 --device 决定
    sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)  # 创建空场景

    # 5) 设置主相机视角：位置与朝向
    sim.set_camera_view([
        2.0, 0.0, 2.5    # 相机位置 (X,Y,Z)
    ], [
        -0.5, 0.0, 0.5   # 相机朝向向量
    ])

    # 6) 设计并填充场景
    design_scene()

    # 7) 重置仿真：清空内部状态并开始运行
    sim.reset()
    print("[INFO]: Setup complete... 场景搭建完成，开始仿真")

    # 8) 循环执行仿真步
    while simulation_app.is_running():
        sim.step()


if __name__ == "__main__":
    main()                # 执行主函数
    simulation_app.close()  # 关闭 Isaac Sim 应用

```


---

### 1. 接入并解析自定义与 AppLauncher 参数

```python
parser = argparse.ArgumentParser(
    description="Tutorial on running IsaacSim via the AppLauncher."
)
parser.add_argument("--size", type=float, default=1.0, help="Side-length of cuboid")
parser.add_argument("--width", type=int, default=1280, help="Width of the viewport …")
parser.add_argument("--height", type=int, default=720, help="Height of the viewport …")

# 将 AppLauncher 本身所需的参数（如 --headless, --device, --renderer 等）注入到同一解析器中
AppLauncher.add_app_launcher_args(parser)
args_cli = parser.parse_args()
```

- **目的**：把你自己脚本的参数（`--size`, `--width`, `--height`）和 `AppLauncher` 所依赖的底层渲染/仿真参数合并在一起，用同一个命令行接口一次性传递给脚本。
    
- **好处**：无需区分两套参数，启动时只需一行命令即可同时控制应用层和仿真层的行为。
    

---

### 2. 通过 `AppLauncher` 启动 Isaac Sim

```python
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app
```

- **`AppLauncher(args_cli)`**：内部会根据命令行参数启动 Omniverse Kit 应用，加载 Isaac Sim 模块，并返回一个封装好的 `Application` 对象。
    
- **`app_launcher.app`**：这是对底层 `SimulationApp` 的引用，用于之后查询“应用是否还在运行”、关闭应用等操作。
    

---

### 3. 设计场景逻辑与 `.func()` 用法

```python
def design_scene():
    cfg_ground = sim_utils.GroundPlaneCfg()
    cfg_ground.func("/World/defaultGroundPlane", cfg_ground)

    cfg_light = sim_utils.DistantLightCfg(intensity=3000.0, color=(0.75,0.75,0.75))
    cfg_light.func("/World/lightDistant", cfg_light, translation=(1,0,10))

    cfg_cuboid = sim_utils.CuboidCfg(size=[args_cli.size]*3, visual_material=...)
    cfg_cuboid.func("/World/Object", cfg_cuboid, translation=(0,0,args_cli.size/2))
```

- **各 `*Cfg` 类**：负责持有一系列参数（几何、物理、材质等）。
    
- **`.func(path, cfg, **kwargs)`**：统一接口，用于
    
    1. 在 USD 场景中创建（或定位）指定路径下的 prim；
        
    2. 将 `cfg` 中的所有配置应用到该 prim；
        
    3. 额外接收 `translation`、`orientation`、`scale` 等 transform 参数。
        

---

### 4. 仿真上下文初始化与主循环

```python
sim_cfg = sim_utils.SimulationCfg(dt=0.01, device=args_cli.device)
sim = sim_utils.SimulationContext(sim_cfg)
sim.set_camera_view([2.0, 0.0, 2.5], [-0.5, 0.0, 0.5])

design_scene()
sim.reset()
while simulation_app.is_running():
    sim.step()
```

- **`SimulationCfg`**：封装了物理仿真的全局设置（时间步长、执行设备等）。
    
- **`SimulationContext`**：在内部构建和管理物理世界状态、时钟、渲染循环。
    
- **`sim.set_camera_view(pos, target)`**：一次性设置相机位置与朝向。
    
- **`sim.reset()`**：启动前重置场景，确保所有 prim、物理状态回到初始。
    
- **循环调用 `sim.step()`**：在每帧里推进一次物理与渲染。
    

---

#### 小结

- **核心就在于**：用 `AppLauncher` 统一管理底层应用的启动和参数，再通过 `sim_utils` 的高阶配置类和 `.func()` 方法快速构建场景，最后在 `SimulationContext` 中集中驱动仿真循环。
    
- 这种分层结构让“启动”、“配置场景”、“运行仿真”三者职责明确，代码既灵活又易于维护。




----

# 将新机器人添加到 Isaac Lab
[将新机器人添加到 Isaac Lab — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/01_assets/add_new_robot.html)

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import argparse
from isaaclab.app import AppLauncher
import numpy as np
import torch
import isaaclab.sim as sim_utils
# 导入 ImplicitActuatorCfg：用于创建显式阻抗执行器，控制关节弹性和阻尼特性
from isaaclab.actuators import ImplicitActuatorCfg
# 资产基础配置，用于定义地面、灯光、机器人等
from isaaclab.assets import AssetBaseCfg
# ArticulationCfg：用于定义可动关节及其物理属性
from isaaclab.assets.articulation import ArticulationCfg
# 交互式场景及其配置类
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg
# Isaac Nucleus 资源路径常量，用于加载 USD 模型
from isaaclab.utils.assets import ISAAC_NUCLEUS_DIR

# ===== 1. 命令行参数配置 =====
# 创建 ArgumentParser 实例用于解析脚本运行时的参数
parser = argparse.ArgumentParser(
    description="此脚本演示如何在 Isaac Lab 环境中添加自定义机器人。"
)
# 用户可指定并行仿真环境数量，默认为 1
parser.add_argument(
    "--num_envs", type=int, default=1,
    help="要创建的并行仿真环境数量。"
)
# 将 AppLauncher 支持的标准参数（如 --headless, --device）加入解析器
AppLauncher.add_app_launcher_args(parser)
# 解析命令行输入，得到 args_cli 对象
args_cli = parser.parse_args()

# ===== 2. 启动 Omniverse Isaac Sim 应用 =====
# 通过 AppLauncher 根据解析参数启动 SimulationApp
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 获取底层 SimulationApp 实例

# ===== 3. 定义两个自定义机器人配置：JETBOT 和 DOFBOT =====
# 3.1 Jetbot：简单驱动机器人，所有关节使用阻抗执行器
JETBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Jetbot/jetbot.usd"
    ),
    actuators={
        # 针对名称匹配正则 ".*" 的所有关节，使用默认阻尼和刚度
        "wheel_acts": ImplicitActuatorCfg(
            joint_names_expr=[".*"],  # 匹配所有关节名称
            damping=None,               # None 表示使用物理默认阻尼
            stiffness=None              # None 表示使用物理默认刚度
        )
    },
)

# 3.2 Dofbot：6-DOF 机械臂，细化物理属性、自碰撞和执行器参数
DOFBOT_CONFIG = ArticulationCfg(
    spawn=sim_utils.UsdFileCfg(
        usd_path=f"{ISAAC_NUCLEUS_DIR}/Robots/Dofbot/dofbot.usd",
        # 定义刚体属性：是否受重力影响和最大分离速度
        rigid_props=sim_utils.RigidBodyPropertiesCfg(
            disable_gravity=False,
            max_depenetration_velocity=5.0,
        ),
        # 定义关节根节点属性：开启自碰撞及迭代求解次数
        articulation_props=sim_utils.ArticulationRootPropertiesCfg(
            enabled_self_collisions=True,
            solver_position_iteration_count=8,
            solver_velocity_iteration_count=0
        ),
    ),
    init_state=ArticulationCfg.InitialStateCfg(
        # 初始关节角位置（rad）
        joint_pos={
            "joint1": 0.0,
            "joint2": 0.0,
            "joint3": 0.0,
            "joint4": 0.0,
        },
        # 机器人整体初始位置偏移（x,y,z）
        pos=(0.25, -0.25, 0.0),
    ),
    actuators={
        # 前两个关节阻抗执行器，可设置力矩和速度限制
        "front_joints": ImplicitActuatorCfg(
            joint_names_expr=["joint[1-2]"],
            effort_limit_sim=100.0,    # 最大扭矩 (Nm)
            velocity_limit_sim=100.0,  # 最大速度 (rad/s)
            stiffness=10000.0,         # 刚度 (N·m/rad)
            damping=100.0,             # 阻尼 (N·m·s/rad)
        ),
        # 独立配置 joint3 和 joint4
        "joint3_act": ImplicitActuatorCfg(
            joint_names_expr=["joint3"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
        "joint4_act": ImplicitActuatorCfg(
            joint_names_expr=["joint4"],
            effort_limit_sim=100.0,
            velocity_limit_sim=100.0,
            stiffness=10000.0,
            damping=100.0,
        ),
    },
)

# ===== 4. 自定义交互式场景配置 =====
class NewRobotsSceneCfg(InteractiveSceneCfg):
    """场景配置：包含地面、全景光照和机器人实例。"""
    # 地面平面，作为机器人行走参考
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",
        spawn=sim_utils.GroundPlaneCfg()
    )
    # 全景半球光，用于模拟环境光照
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,          # 光照强度
            color=(0.75, 0.75, 0.75)     # 灯光颜色 (RGB)
        )
    )
    # 将机器人配置绑定到命名空间，支持多环境实例化
    Jetbot = JETBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Jetbot")
    Dofbot = DOFBOT_CONFIG.replace(prim_path="{ENV_REGEX_NS}/Dofbot")

# ===== 5. 仿真主循环逻辑 =====
def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """执行仿真步进、机器人控制和周期性重置。"""
    # 获取物理仿真步长 (秒)
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0  # 累计仿真时间
    count = 0       # 计步器，用于定时动作切换和重置

    # 当窗口未关闭时持续运行
    while simulation_app.is_running():
        # 每隔 500 步重置机器人到初始状态
        if count % 500 == 0:
            count = 0
            # 克隆默认根部状态，并根据环境原点偏移
            root_jetbot = scene["Jetbot"].data.default_root_state.clone()
            root_jetbot[:, :3] += scene.env_origins
            root_dofbot = scene["Dofbot"].data.default_root_state.clone()
            root_dofbot[:, :3] += scene.env_origins

            # 将位置、姿态和速度写回仿真
            scene["Jetbot"].write_root_pose_to_sim(root_jetbot[:, :7])
            scene["Jetbot"].write_root_velocity_to_sim(root_jetbot[:, 7:])
            scene["Dofbot"].write_root_pose_to_sim(root_dofbot[:, :7])
            scene["Dofbot"].write_root_velocity_to_sim(root_dofbot[:, 7:])

            # 重置关节位置和速度
            jp, jv = (
                scene["Jetbot"].data.default_joint_pos.clone(),
                scene["Jetbot"].data.default_joint_vel.clone(),
            )
            scene["Jetbot"].write_joint_state_to_sim(jp, jv)
            jp, jv = (
                scene["Dofbot"].data.default_joint_pos.clone(),
                scene["Dofbot"].data.default_joint_vel.clone(),
            )
            scene["Dofbot"].write_joint_state_to_sim(jp, jv)

            scene.reset()  # 场景全局重置，多环境同时作用
            print("[INFO]: 重置 Jetbot 和 Dofbot 状态...")

        # ===== 机器人控制逻辑 =====
        # Jetbot: 直行与转向交替，每 100 步内前 75 步直行，后 25 步转弯
        if count % 100 < 75:
            action = torch.Tensor([[10.0, 10.0]])  # 左右轮相同速率，直行
        else:
            action = torch.Tensor([[5.0, -5.0]])   # 反向差速，原地转动
        scene["Jetbot"].set_joint_velocity_target(action)

        # Dofbot: 四个关节做正弦波振动，幅度 0.25 rad，频率 0.5 Hz
        wave_action = scene["Dofbot"].data.default_joint_pos
        wave_action[:, 0:4] = 0.25 * np.sin(2 * np.pi * 0.5 * sim_time)
        scene["Dofbot"].set_joint_position_target(wave_action)

        # 写入所有命令并推进仿真一步
        scene.write_data_to_sim()
        sim.step()
        sim_time += sim_dt
        count += 1
        # 更新场景渲染和交互
        scene.update(sim_dt)

# ===== 6. 程序入口 =====
def main():
    """脚本入口：初始化仿真上下文和场景，并启动循环。"""
    # 构造仿真配置，包括设备类型（CPU/GPU）
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = sim_utils.SimulationContext(sim_cfg)

    # 可选：设置默认摄像机视角 (位置, 朝向)
    sim.set_camera_view([3.5, 0.0, 3.2], [0.0, 0.0, 0.5])

    # 构建场景配置，指定环境数量和间距
    scene_cfg = NewRobotsSceneCfg(args_cli.num_envs, env_spacing=2.0)
    scene = InteractiveScene(scene_cfg)

    sim.reset()  # 初始化仿真状态
    print("[INFO]: 设置完成，开始运行仿真...")
    run_simulator(sim, scene)

if __name__ == "__main__":
    main()
    # 退出时关闭应用窗口，释放资源
    simulation_app.close()

```

==关键解读==：

1. **ImplicitActuatorCfg vs ArticulationCfg**

- **ArticulationCfg**  
    这是对“树状关节（Articulation）”整体的配置，通常包括：
    
    - 铰链／关节数量与拓扑
        
    - 各关节的物理属性（质量、惯量、摩擦、初始位置等）
        
    - 刚体之间的连接方式（铰链、滑动、球铰）
        
    - 关节限制（转动角度／线性位移范围）
        
    - 动力学求解器参数（比如 solver iteration count）  
        简言之，`ArticulationCfg` 定义了一个多关节机器人或机械臂的物理骨架与动力学属性。
        
- **ImplicitActuatorCfg**  
    这是针对“隐式执行器（Implicit Actuator）”的配置。隐式执行器通常指在动力学求解过程中，将执行器力（torque/force）以“隐式积分”方式加入求解器，以提升数值稳定性。它包含：
    
    - 执行器类型（位置控制、力控制、阻抗控制等）
        
    - 控制参数（刚度 `stiffness`、阻尼 `damping`、最大力矩等）
        
    - 目标命令格式（位置目标、速度目标或力目标）  
        简单说，`ImplicitActuatorCfg` 定义了如何把高层控制命令转换为关节／驱动力，并以隐式方式与物理引擎耦合。
        

---

 2. **阻抗执行器（Impedance Actuator）是什么？**

阻抗控制（Impedance Control）是一种把机器人关节或末端执行器当作弹簧-阻尼系统来控制的方法。与“纯位置控制”不同，阻抗执行器会根据：

- 目标位置偏差 → 产生弹性力（`F = K (x_target − x_actual)`）
    
- 速度差异 → 产生阻尼力（`F = D (v_target − v_actual)`）  
    这样，当执行器和环境发生接触时，它能以更自然的“软”响应来吸收冲击，增强交互安全性与稳定性。
    

在隐式执行器中，阻抗模型的力直接融入物理求解器矩阵，允许大步长且更稳定地模拟高刚度情形。

---

3. **将机器人绑定到实例空间（instance space）是什么意思？**

在多场景或多并发仿真中，“实例空间”指一组“相同模型”的并行副本。

- 你把一个机器人模型（URDF／USD）实例化多份，每份称为一个“实例”。
    
- “绑定到实例空间”即把这具机器人物理骨架、状态跟踪、碰撞体等关联到某个实例 ID，使后续的状态更新、碰撞检测、渲染等，都在这个命名空间里并行进行。
    
- 这样你就可以一次性批量加载 N 个机器人，利用 GPU 并行加速物理与感知。
    

---

4. **`def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):` 这里是什么？**

这里是一个函数定义，接收两个参数：

- `sim: sim_utils.SimulationContext`：封装物理引擎、时间步长、步进函数等。
    
- `scene: InteractiveScene`：封装场景资源、渲染相机、交互事件等。
    

它是你的控制脚本里向引擎传入“仿真上下文”与“场景对象”，然后在函数内部启动主循环。

---

5. **`root_jetbot = scene["Jetbot"].data.default_root_state.clone()` 是做什么用的？**

- `scene["Jetbot"]`：通过名字从场景中取到名为 “Jetbot” 的实体（Instance）。
    
- `.data.default_root_state`：这是这具机器人的“默认根状态”（一般包括全局位置、朝向、各关节初始角度）。
    
- `.clone()`：复制一份这个状态副本，避免直接修改原始模板。
    

**用途**：拿到该机器人从零加载时的基准状态，之后可以在仿真开始前或复位时，直接把它设回这份克隆状态。

---

# 与刚性物体交互

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
本脚本演示如何在 Isaac Sim 中创建一个刚性物体并与之交互。

使用方法：
    ./isaaclab.sh -p scripts/tutorials/01_assets/run_rigid_object.py
"""

"""启动 Isaac Sim 仿真器后，再执行本脚本。"""

import argparse
from isaaclab.app import AppLauncher

# —— 命令行参数配置 —— #
# 创建参数解析器，描述本教程用途
parser = argparse.ArgumentParser(
    description="Tutorial on spawning and interacting with a rigid object."
)
# 添加 Isaac Lab 通用启动器参数（如设备、GUI 开关等）
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# —— 启动仿真应用 —— #
# 使用解析出的参数创建并启动 Omniverse 应用
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app  # 返回已启动的仿真应用句柄

"""之后的内容均在仿真环境启动后执行。"""

import torch
import isaacsim.core.utils.prims as prim_utils
import isaaclab.sim as sim_utils
import isaaclab.utils.math as math_utils
from isaaclab.assets import RigidObject, RigidObjectCfg
from isaaclab.sim import SimulationContext


def design_scene():
    """设计场景：包含地面、光源、坐标原点组及刚性物体。"""
    # 1. 地面平面配置
    cfg = sim_utils.GroundPlaneCfg()
    # 将地面添加至场景根路径
    cfg.func("/World/defaultGroundPlane", cfg)

    # 2. 场景环境光
    cfg = sim_utils.DomeLightCfg(
        intensity=2000.0,  # 灯光强度
        color=(0.8, 0.8, 0.8)  # 灯光颜色（RGB）
    )
    cfg.func("/World/Light", cfg)

    # 3. 创建设定的多个坐标原点，用于多实例场景测试
    origins = [
        [0.25, 0.25, 0.0],
        [-0.25, 0.25, 0.0],
        [0.25, -0.25, 0.0],
        [-0.25, -0.25, 0.0],
    ]
    for i, origin in enumerate(origins):
        # 在 /World 下依次创建 Origin0, Origin1... 的 Xform 节点
        prim_utils.create_prim(
            f"/World/Origin{i}", "Xform", translation=origin
        )

    # 4. 刚性物体配置：生成多个绿色圆锥体的刚性配置
    cone_cfg = RigidObjectCfg(
        prim_path="/World/Origin.*/Cone",  # USD 路径支持正则匹配
        spawn=sim_utils.ConeCfg(
            radius=0.1,  # 圆锥半径
            height=0.2,  # 圆锥高度
            rigid_props=sim_utils.RigidBodyPropertiesCfg(),  # 刚体物理属性
            mass_props=sim_utils.MassPropertiesCfg(mass=1.0),  # 质量属性
            collision_props=sim_utils.CollisionPropertiesCfg(),  # 碰撞属性
            visual_material=sim_utils.PreviewSurfaceCfg(
                diffuse_color=(0.0, 1.0, 0.0),  # 绿色
                metallic=0.2  # 金属感
            ),
        ),
        init_state=RigidObjectCfg.InitialStateCfg(),  # 初始状态配置
    )
    # 实例化 RigidObject，负责管理物体生命周期与接口
    cone_object = RigidObject(cfg=cone_cfg)

    # 返回场景实体与原点列表，用于后续仿真
    scene_entities = {"cone": cone_object}
    return scene_entities, origins


def run_simulator(
    sim: sim_utils.SimulationContext,
    entities: dict[str, RigidObject],
    origins: torch.Tensor,
):
    """仿真主循环：包括重置、物理步进、状态更新与打印。"""
    # 从实体字典中提取刚性物体对象
    cone_object = entities["cone"]
    # 物理步长与计时器初始化
    sim_dt = sim.get_physics_dt()  # 从仿真上下文获取 dt
    sim_time = 0.0  # 模拟时间
    count = 0  # 步骤计数

    # 主循环：当仿真应用窗口未关闭时持续执行
    while simulation_app.is_running():
        # —— 重置逻辑：每250步重置一次（例如用于随机化初始位置） —— #
        if count % 250 == 0:
            sim_time = 0.0  # 重置模拟时间
            count = 0  # 重置步数计数
            # 1) 恢复默认根状态
            root_state = cone_object.data.default_root_state.clone()
            # 2) 叠加环境原点偏移
            root_state[:, :3] += origins
            # 3) 在圆柱体区域内随机采样位置，增加随机性
            root_state[:, :3] += math_utils.sample_cylinder(
                radius=0.1,
                h_range=(0.25, 0.5),
                size=cone_object.num_instances,
                device=cone_object.device,
            )
            # 4) 写入仿真：位置 + 朝向（前7维）
            cone_object.write_root_pose_to_sim(root_state[:, :7])
            # 5) 写入仿真：线速度 + 角速度（后6维）
            cone_object.write_root_velocity_to_sim(root_state[:, 7:])
            # 完成数据写入后调用 reset 清理内部缓冲
            cone_object.reset()
            print("----------------------------------------")
            print("[INFO]: Resetting object state...")

        # —— 将脚本中管理的数据写入仿真 —— #
        cone_object.write_data_to_sim()
        # —— 推进物理一步 —— #
        sim.step()
        # —— 更新时间与步数 —— #
        sim_time += sim_dt
        count += 1
        # —— 从仿真中拉取最新状态到脚本缓冲 —— #
        cone_object.update(sim_dt)
        # 每50步打印当前根位置，观察运动轨迹
        if count % 50 == 0:
            pos = cone_object.data.root_state_w[:, :3]
            print(f"Root position (in world): {pos}")


def main():
    """入口函数：初始化仿真、设计场景并启动主循环。"""
    # 1) 创建仿真配置并上下文
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = SimulationContext(sim_cfg)
    # 2) 设置主相机视角，便于观察场景
    sim.set_camera_view(
        eye=[1.5, 0.0, 1.0],  # 相机位置
        target=[0.0, 0.0, 0.0],  # 相机目标点
    )
    # 3) 设计场景：地面、光源、原点组与刚性物体
    scene_entities, scene_origins = design_scene()
    # 转为张量并移动到正确设备
    scene_origins = torch.tensor(scene_origins, device=sim.device)
    # 4) 重置仿真，加载所有 USD 资源和配置
    sim.reset()
    print("[INFO]: Setup complete...")
    # 5) 进入仿真主循环
    run_simulator(sim, scene_entities, scene_origins)


# 脚本入口检测
if __name__ == "__main__":
    main()
    # 当主循环结束（如窗口关闭）后，关闭仿真应用
    simulation_app.close()

```


==解读：==


1. **`CollisionPropertiesCfg` 可配置的参数**

`sim_utils.CollisionPropertiesCfg` 用于控制刚体的碰撞行为，你可以通过它来精细调节物理引擎中碰撞检测和接触力学的属性。常见可选参数（以关键字方式传入）包括：

|参数名|含义|类型／默认值|
|---|---|---|
|`restitution`|反弹系数，决定碰撞后物体的回弹程度，范围 0,10,1|`float`, 默认约 `0.0`|
|`static_friction`|静摩擦系数，在接触初始阶段抗滑动的能力|`float`, 默认约 `0.5`|
|`dynamic_friction`|动摩擦系数，物体相对滑动时的摩擦大小|`float`, 默认约 `0.5`|
|`friction_direction`|自定义摩擦方向（用于各向异性摩擦），通常留空使用默认|`Tuple[float, float, float]`|
|`contact_offset`|“近场接触”检测距离阈值，小于该距离即认为发生接触|`float`, 默认约 `0.01` m|
|`rest_offset`|“稳定接触”阈值，低于此距离物体会被视作已稳定接触|`float`, 默认约 `0.0` m|
|`enable_ccd`|是否开启连续碰撞检测（Continuous Collision Detection）|`bool`, 默认 `False`|
|`ccd_thickness`|若开启 CCD，此厚度决定能检测到的最小穿透厚度|`float`, 默认约 `0.01` m|
|`solver_position_iteration_count`|碰撞求解器在位置修正时的迭代次数|`int`, 默认约 `4`|
|`solver_velocity_iteration_count`|碰撞求解器在速度修正时的迭代次数|`int`, 默认约 `1`|

 **示例**
```python

 collision_props = sim_utils.CollisionPropertiesCfg(
     restitution=0.1,
     static_friction=0.6,
    dynamic_friction=0.4,
    contact_offset=0.02,
    enable_ccd=True,
     ccd_thickness=0.005
 )
 ```


2. **`init_state=RigidObjectCfg.InitialStateCfg()` 的作用**

`InitialStateCfg` 是用来指定刚体在「首次生成」或「场景重置」时的初始状态（位姿／速度）配置类。通常它包含：

- **位置与朝向**（Position & Orientation）  
    可以自行传入一个固定的 `pose`，或者使用默认的 USD 路径里定义的初始位姿。
    
- **线速度与角速度**（Linear & Angular Velocity）  
    若你希望物体一生成就携带一定初速度，例如抛射体，就可以在这里设置。
    
- **随机化选项**  
    有些扩展版本支持在初始状态上加噪声或随机化（例如 `pos_range`, `ori_range`），用于批量场景随机测试。
    

如果你不传任何参数（如示例中的空调用），它会使用 USD 文件里定义的「默认根状态」和「默认速度」作为物体的初始状态。

---

3. **为什么要 `cone_object = RigidObject(cfg=cone_cfg)` 实例化？**

把配置（`RigidObjectCfg`）“落实”到仿真中，需要创建一个**对象实例**来管理它的全生命周期和接口：

1. **资源加载**
    
    - 实例化时，内部会根据 `cfg.prim_path`、`spawn` 设定真正往 USD 场景里生成对应的几何体、物理体、碰撞体与材质。
        
2. **数据缓冲**
    
    - 生成后会分配一系列缓冲区（root_state、joint_state、接触信息等），用于在脚本和仿真引擎之间高效同步。
        
3. **API 接口**
    
    - 实例对象提供 `write_root_pose_to_sim`、`write_data_to_sim`、`reset`、`update` 等方法，让你可以在仿真主循环里很方便地：
        
        - 写入新的位姿／速度
            
        - 推送关节／状态更新
            
        - 拉取反馈信息（如最新的世界坐标、接触力）
            
        - 一键复位到初始状态
            
4. **多实例管理**
    
    - 如果你在同一个场景里需要多个相同配置的物体，只需多次实例化同一个配置，它们就会自动在不同的 `prim_path`（比如用正则 `/World/Origin.*/Cone`）下同步生成并分开管理。
        

简而言之，**配置只是“蓝图”，而实例化才是真正把物体“搭”到仿真世界里，并赋予它可操作的接口与数据通道**。没有实例化，你就没有后续写状态、读状态、调用物理步等一切操作的句柄。


---


# 与关节交互
[与关节交互 — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/01_assets/run_articulation.html)

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""本脚本演示了如何创建一个倒立摆(cart-pole)并与之交互。

.. code-block:: bash

    # 使用方法
    ./isaaclab.sh -p scripts/tutorials/01_assets/run_articulation.py

"""

"""首先启动Isaac Sim模拟器。"""


import argparse

from isaaclab.app import AppLauncher

# 添加命令行参数
parser = argparse.ArgumentParser(description="关于创建和交互关节体(articulation)的教程。")
# 添加AppLauncher命令行参数
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# 启动Omniverse应用程序
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""以下是主要代码部分。"""

import torch

import isaacsim.core.utils.prims as prim_utils

import isaaclab.sim as sim_utils
from isaaclab.assets import Articulation
from isaaclab.sim import SimulationContext

##
# 预定义配置
##
from isaaclab_assets import CARTPOLE_CFG  # 倒立摆配置


def design_scene() -> tuple[dict, list[list[float]]]:
    """设计场景。
    
    返回:
        tuple: 包含场景实体字典和原点位置列表的元组
    """
    # 创建地面
    cfg = sim_utils.GroundPlaneCfg()
    cfg.func("/World/defaultGroundPlane", cfg)
    # 创建灯光
    cfg = sim_utils.DomeLightCfg(intensity=3000.0, color=(0.75, 0.75, 0.75))
    cfg.func("/World/Light", cfg)

    # 创建两个独立的坐标组："Origin1"和"Origin2"
    # 每个组将包含一个机器人
    origins = [[0.0, 0.0, 0.0], [-1.0, 0.0, 0.0]]
    # 创建Origin1
    prim_utils.create_prim("/World/Origin1", "Xform", translation=origins[0])
    # 创建Origin2
    prim_utils.create_prim("/World/Origin2", "Xform", translation=origins[1])

    # 创建关节体(倒立摆)
    cartpole_cfg = CARTPOLE_CFG.copy()
    cartpole_cfg.prim_path = "/World/Origin.*/Robot"  # 使用通配符匹配两个Origin下的Robot
    cartpole = Articulation(cfg=cartpole_cfg)

    # 返回场景信息，包括两个倒立摆实例和两个原点
    scene_entities = {"cartpole": cartpole}
    return scene_entities, origins


def run_simulator(sim: sim_utils.SimulationContext, entities: dict[str, Articulation], origins: torch.Tensor):
    """运行模拟循环。
    
    参数:
        sim: 模拟上下文对象
        entities: 包含场景实体的字典
        origins: 原点位置的张量
    """
    # 提取场景实体
    # 注意：我们在这里这样做只是为了提高可读性。通常，最好直接从字典中访问实体。
    # 在下一个教程中，这个字典将被InteractiveScene类替代。
    robot = entities["cartpole"]
    # 定义模拟步长
    sim_dt = sim.get_physics_dt()
    count = 0
    # 模拟循环
    while simulation_app.is_running():
        # 重置
        if count % 500 == 0:
            # 重置计数器
            count = 0
            # 重置场景实体
            # 根状态
           
            # 如果不这样做，机器人将在模拟世界的(0, 0, 0)点生成
            root_state = robot.data.default_root_state.clone()
            # 我们通过原点偏移根状态，因为状态是在模拟世界坐标系中写入的 
            root_state[:, :3] += origins
            # 写入位姿(位置和旋转)
            robot.write_root_pose_to_sim(root_state[:, :7])  
            robot.write_root_velocity_to_sim(root_state[:, 7:])  # 写入速度
            # 设置关节位置，并添加一些随机噪声
            joint_pos, joint_vel = robot.data.default_joint_pos.clone(), robot.data.default_joint_vel.clone()
            joint_pos += torch.rand_like(joint_pos) * 0.1  # 添加随机噪声
            robot.write_joint_state_to_sim(joint_pos, joint_vel)
            # 清除内部缓冲区
            robot.reset()
            print("[信息]: 重置机器人状态...")
        # 应用随机动作
        # -- 生成随机关节力矩
        efforts = torch.randn_like(robot.data.joint_pos) * 5.0
        # -- 将动作应用到机器人
        robot.set_joint_effort_target(efforts)
        # -- 将数据写入模拟器
        robot.write_data_to_sim()
        # 执行模拟步进
        sim.step()
        # 增加计数器
        count += 1
        # 更新缓冲区
        robot.update(sim_dt)


def main():
    """主函数。"""
    # 加载模拟工具
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = SimulationContext(sim_cfg)
    # 设置主摄像机视角
    sim.set_camera_view([2.5, 0.0, 4.0], [0.0, 0.0, 2.0])
    # 设计场景
    scene_entities, scene_origins = design_scene()
    scene_origins = torch.tensor(scene_origins, device=sim.device)
    # 运行模拟器
    sim.reset()
    # 准备完毕
    print("[信息]: 设置完成...")
    # 运行模拟器
    run_simulator(sim, scene_entities, scene_origins)


if __name__ == "__main__":
    # 运行主函数
    main()
    # 关闭模拟器应用
    simulation_app.close()

```

1. **`robot.set_joint_effort_target(efforts)`**  
    这是设置“**力矩（effort）控制模式**”下的标准接口：
    
    - `efforts` 张量里的每个元素对应一个关节要施加的扭矩（单位通常是牛·米 Nm）。
        
    - 调用后，仿真引擎会在下一次物理步进中，将这些扭矩作用到对应关节上。
        
    - 这种“扭矩控制”是机器人仿真／控制中最底层、最直接的一种方式，常用于实现纯力矩驱动的控制策略（比如强化学习、随机测试、力反馈等）。
        

当然，Isaac Lab 也支持其它控制模式，比如：

- **位置控制**：`set_joint_position_target(...)`，给定关节目标角度＋内置 PID 控制；
    
- **速度控制**：`set_joint_velocity_target(...)`，给定关节目标转速＋PID；
    
- **混合控制**：自己组合位置／速度／力矩。



----
# 与可变形物体交互

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
本脚本演示了如何使用可变形物体并与之交互。

.. code-block:: bash

    # 使用方法
    ./isaaclab.sh -p scripts/tutorials/01_assets/run_deformable_object.py

"""

"""首先启动Isaac Sim模拟器。"""


import argparse

from isaaclab.app import AppLauncher

# 添加命令行参数
parser = argparse.ArgumentParser(description="关于与可变形物体交互的教程。")
# 添加AppLauncher命令行参数
AppLauncher.add_app_launcher_args(parser)
# 解析命令行参数
args_cli = parser.parse_args()

# 启动Omniverse应用程序
app_launcher = AppLauncher(args_cli)
simulation_app = app_launcher.app

"""以下是主要代码部分。"""

import torch

import isaacsim.core.utils.prims as prim_utils

import isaaclab.sim as sim_utils
import isaaclab.utils.math as math_utils
from isaaclab.assets import DeformableObject, DeformableObjectCfg
from isaaclab.sim import SimulationContext


def design_scene():
    """设计场景。
    
    返回:
        tuple: 包含场景实体字典和原点位置列表的元组
    """
    # 创建地面
    cfg = sim_utils.GroundPlaneCfg()
    cfg.func("/World/defaultGroundPlane", cfg)
    # 创建灯光
    cfg = sim_utils.DomeLightCfg(intensity=2000.0, color=(0.8, 0.8, 0.8))
    cfg.func("/World/Light", cfg)

    # 创建四个独立的坐标组："Origin0", "Origin1", "Origin2", "Origin3"
    # 每个组将包含一个可变形物体
    origins = [[0.25, 0.25, 0.0], [-0.25, 0.25, 0.0], [0.25, -0.25, 0.0], [-0.25, -0.25, 0.0]]
    for i, origin in enumerate(origins):
        prim_utils.create_prim(f"/World/Origin{i}", "Xform", translation=origin)

    # 创建可变形物体
    cfg = DeformableObjectCfg(
        prim_path="/World/Origin.*/Cube",  # 使用通配符匹配所有Origin下的Cube
        spawn=sim_utils.MeshCuboidCfg(
            size=(0.2, 0.2, 0.2),  # 设置立方体大小
            deformable_props=sim_utils.DeformableBodyPropertiesCfg(rest_offset=0.0, contact_offset=0.001),  # 设置可变形属性
            visual_material=sim_utils.PreviewSurfaceCfg(diffuse_color=(0.5, 0.1, 0.0)),  # 设置视觉材质和颜色
            physics_material=sim_utils.DeformableBodyMaterialCfg(poissons_ratio=0.4, youngs_modulus=1e5),  # 设置物理材质属性
        ),
        init_state=DeformableObjectCfg.InitialStateCfg(pos=(0.0, 0.0, 1.0)),  # 设置初始位置
        debug_vis=True,  # 启用调试可视化
    )
    cube_object = DeformableObject(cfg=cfg)

    # 返回场景信息
    scene_entities = {"cube_object": cube_object}
    return scene_entities, origins


def run_simulator(sim: sim_utils.SimulationContext, entities: dict[str, DeformableObject], origins: torch.Tensor):
    """运行模拟循环。
    
    参数:
        sim: 模拟上下文对象
        entities: 包含场景实体的字典
        origins: 原点位置的张量
    """
    # 提取场景实体
    # 注意：我们在这里这样做只是为了提高可读性。通常，最好直接从字典中访问实体。
    # 在下一个教程中，这个字典将被InteractiveScene类替代。
    cube_object = entities["cube_object"]
    # 定义模拟步长
    sim_dt = sim.get_physics_dt()
    sim_time = 0.0
    count = 0

    # 可变形体的节点运动学目标
    nodal_kinematic_target = cube_object.data.nodal_kinematic_target.clone()

    # 开始物理模拟
    while simulation_app.is_running():
        # 重置
        if count % 250 == 0:
            # 重置计数器
            sim_time = 0.0
            count = 0

            # 重置物体的节点状态
            nodal_state = cube_object.data.default_nodal_state_w.clone()
            # 对物体应用随机姿态
            pos_w = torch.rand(cube_object.num_instances, 3, device=sim.device) * 0.1 + origins  # 随机位置加上原点偏移
            quat_w = math_utils.random_orientation(cube_object.num_instances, device=sim.device)  # 随机方向
            nodal_state[..., :3] = cube_object.transform_nodal_pos(nodal_state[..., :3], pos_w, quat_w)  # 转换节点位置

            # 将节点状态写入模拟器
            cube_object.write_nodal_state_to_sim(nodal_state)

            # 将节点状态写入运动学目标并释放所有顶点
            nodal_kinematic_target[..., :3] = nodal_state[..., :3]
            nodal_kinematic_target[..., 3] = 1.0  # 1.0表示顶点自由移动
            cube_object.write_nodal_kinematic_target_to_sim(nodal_kinematic_target)

            # 重置缓冲区
            cube_object.reset()

            print("----------------------------------------")
            print("[信息]: 重置物体状态...")

        # 更新索引为0和3的立方体的运动学目标
        # 通过拾取索引为0的顶点，在z方向上稍微移动立方体
        nodal_kinematic_target[[0, 3], 0, 2] += 0.001
        # 将索引为0的顶点设置为受运动学约束
        # 0: 受约束(固定), 1: 自由移动
        nodal_kinematic_target[[0, 3], 0, 3] = 0.0
        # 将运动学目标写入模拟器
        cube_object.write_nodal_kinematic_target_to_sim(nodal_kinematic_target)

        # 将内部数据写入模拟器
        cube_object.write_data_to_sim()
        # 执行模拟步进
        sim.step()
        # 更新模拟时间
        sim_time += sim_dt
        count += 1
        # 更新缓冲区
        cube_object.update(sim_dt)
        # 打印根位置
        if count % 50 == 0:
            print(f"根位置(世界坐标系): {cube_object.data.root_pos_w[:, :3]}")


def main():
    """主函数。"""
    # 加载模拟工具
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = SimulationContext(sim_cfg)
    # 设置主摄像机视角
    sim.set_camera_view(eye=[3.0, 0.0, 1.0], target=[0.0, 0.0, 0.5])
    # 设计场景
    scene_entities, scene_origins = design_scene()
    scene_origins = torch.tensor(scene_origins, device=sim.device)
    # 运行模拟器
    sim.reset()
    # 准备完毕
    print("[信息]: 设置完成...")
    # 运行模拟器
    run_simulator(sim, scene_entities, scene_origins)


if __name__ == "__main__":
    # 运行主函数
    main()
    # 关闭模拟器应用
    simulation_app.close()

```

==核心代码解读:==

**`spawn`: 网格与物理属性配置**

这部分是一个 `MeshCuboidCfg` 对象，用来指定立方体的几何、可变形物理属性，以及外观材质。

```python
spawn=sim_utils.MeshCuboidCfg(
    size=(0.2, 0.2, 0.2),
    deformable_props=sim_utils.DeformableBodyPropertiesCfg(
        rest_offset=0.0,
        contact_offset=0.001
    ),
    visual_material=sim_utils.PreviewSurfaceCfg(
        diffuse_color=(0.5, 0.1, 0.0)
    ),
    physics_material=sim_utils.DeformableBodyMaterialCfg(
        poissons_ratio=0.4,
        youngs_modulus=1e5
    ),
),

```

|参数|含义|
|---|---|
|**size**|物理网格的长宽高 (米)。这里是 20cm³ 的立方体。|
|**rest_offset**|设置网格表面与刚体/其它碰撞体的“松驰”距离。  <br>0.0 表示紧贴。|
|**contact_offset**|碰撞检测的触发距离。  <br>0.001 米 = 1 mm。|
|**diffuse_color**|视觉材质的漫反射颜色 RGB 值。|
|**poissons_ratio**|泊松比，描述材料的横向收缩 vs 纵向拉伸关系，典型取值 0.0–0.5。|
|**youngs_modulus**|杨氏模量（Pa），衡量材料刚度：数值越大越“硬”。|

- **deformable_props**：控制碰撞层与物体之间的间隙和接触灵敏度。
    
- **physics_material**：决定形变时内部力学行为。


2. 拉扯物体
```python
# 更新索引为0和3的立方体的运动学目标
# 通过拾取索引为0的顶点，在z方向上稍微移动立方体
nodal_kinematic_target[[0, 3], 0, 2] += 0.001
# 将索引为0的顶点设置为受运动学约束
# 0: 受约束(固定), 1: 自由移动
nodal_kinematic_target[[0, 3], 0, 3] = 0.0
# 将运动学目标写入模拟器
cube_object.write_nodal_kinematic_target_to_sim(nodal_kinematic_target)
```

nodal_kinematic_target的形状是`[num_instances, num_nodes, 4]`
- **`num_instances`**：这里是 4，因为我们在四个 Origin 下各生成了一个 Cube 实例。
    
- **`num_nodes`**：每个可变形网格的顶点数（节点数），由底层网格细分决定。
    
- **最后一个维度 4**：对应 `[target_x, target_y, target_z, lock_flag]`
    
    - `target_x/y/z`：这个顶点运动学目标位置（世界坐标系）。
        
    - `lock_flag`：控制该顶点是否被“运动学驱动”（0＝完全锁定，不受物理力；1＝完全自由，由物理求解器驱动）。

---
# 使用交互式场景
在之前的教程中，我们通过手动方式将资产==生成==（`spawn`）到仿真环境中，并创建对象实例与之交互。但随着场景复杂度提升，这种手动操作会变得繁琐。本教程将介绍`scene.InteractiveScene`类，它提供了管理仿真中**prim**生成与交互的便捷接口。

从架构上看，交互式场景（**interactive scene**）是场景实体（**scene entities**）的集合。每个实体可以是：

- 非交互式**prim**（如地面平面、光源）
    
- 交互式**prim**（如articulation、rigid body）
    
- 传感器（如camera、LiDAR）
    

与手动操作相比，该方案具有以下优势：

- **自动化生成**：自动处理prim生成流程，无需用户逐个操作
    
- **批量克隆**：支持多环境下的场景prim快速复制
    
- **统一管理**：通过单一对象集中管理所有场景实体
    

本教程将以[[#与关节交互]]中的**cartpole**示例为基础，用==scene.InteractiveScene==对象替代原有的design_scene函数。虽然当前简单场景中使用该方案可能显得冗余，但随着更多asset和sensor的加入，其价值将显著体现。

==下面的代码拿来和[[#与关节交互]]对比==


```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
本脚本演示了如何使用交互式场景（InteractiveScene）接口
来一次性创建多个环境（envs）中的多个 prims（如地面、灯光、倒立摆机器人）并进行仿真。

使用示例:
    ./isaaclab.sh -p scripts/tutorials/02_scene/create_scene.py --num_envs 32
"""

# 首先，导入标准库 argparse，用于解析命令行参数
import argparse

# 从 isaaclab.app 中导入 AppLauncher，用于启动 Omniverse Isaac Sim 应用
from isaaclab.app import AppLauncher

# 创建 ArgumentParser 实例，用于接收脚本运行参数
parser = argparse.ArgumentParser(description="使用交互式场景接口的教程。")
# 添加 --num_envs 参数，指定要生成的环境数量，默认为 2
parser.add_argument("--num_envs", type=int, default=2, help="要生成的环境数量。")
# 将 AppLauncher 所需的命令行参数追加到 parser
AppLauncher.add_app_launcher_args(parser)
# 解析所有命令行参数，结果存放在 args_cli 中
args_cli = parser.parse_args()

# 实例化并启动 Omniverse 应用，根据 args_cli 中的配置（如设备、渲染模式等）
app_launcher = AppLauncher(args_cli)
# 获取已启动的 simulation_app 对象，用于后续窗口状态检查
simulation_app = app_launcher.app

# 接下来才是真正的脚本核心逻辑

import torch

# 导入仿真工具和上下文
import isaaclab.sim as sim_utils
from isaaclab.assets import ArticulationCfg, AssetBaseCfg
from isaaclab.scene import InteractiveScene, InteractiveSceneCfg
from isaaclab.sim import SimulationContext
from isaaclab.utils import configclass

# 导入预定义倒立摆配置
from isaaclab_assets import CARTPOLE_CFG  # isort:skip


@configclass
class CartpoleSceneCfg(InteractiveSceneCfg):
    """
    继承自 InteractiveSceneCfg，用于配置一个多环境的倒立摆场景。
    """

    # 配置地面平面 prim
    ground = AssetBaseCfg(
        prim_path="/World/defaultGroundPlane",  # 世界根节点下的默认地面
        spawn=sim_utils.GroundPlaneCfg()         # 使用仿真工具中的 GroundPlaneCfg
    )

    # 配置环境光源（DomeLight）
    dome_light = AssetBaseCfg(
        prim_path="/World/Light",               # 灯光 prim 路径
        spawn=sim_utils.DomeLightCfg(
            intensity=3000.0,                     # 光强
            color=(0.75, 0.75, 0.75)              # 灯光颜色（RGB）
        )
    )

    # 配置倒立摆机器人
    # 使用预定义的 CARTPOLE_CFG，但将 prim_path 改为 "{ENV_REGEX_NS}/Robot"
    # 其中 {ENV_REGEX_NS} 会被 InteractiveScene 根据环境索引展开为 /World/Env_0、/World/Env_1 等
    cartpole: ArticulationCfg = CARTPOLE_CFG.replace(
        prim_path="{ENV_REGEX_NS}/Robot"
    )


def run_simulator(sim: sim_utils.SimulationContext, scene: InteractiveScene):
    """运行仿真主循环逻辑"""
    # 从 scene 中取出倒立摆实体，简化后续调用
    robot = scene["cartpole"]
    # 获取物理子步长，用于更新时钟计算
    sim_dt = sim.get_physics_dt()
    # 计数器，用于周期性重置
    count = 0

    # 只要应用窗口未关闭，就持续运行仿真
    while simulation_app.is_running():
        # 每 500 步进行一次重置
        if count % 500 == 0:
            count = 0  # 重置计数器

            # 重置机器人的根变换状态（位置 + 姿态 + 速度）
            # 首先克隆默认根状态
            root_state = robot.data.default_root_state.clone()
            # 将根位置在世界坐标中偏移至各自环境起点
            root_state[:, :3] += scene.env_origins
            # 写入姿态（位置 + 四元数）到仿真
            robot.write_root_pose_to_sim(root_state[:, :7])
            # 写入根速度到仿真
            robot.write_root_velocity_to_sim(root_state[:, 7:])

            # 重置关节状态（位置 + 速度）
            # 在默认位置上添加少量随机噪声，增加多样性
            joint_pos, joint_vel = (
                robot.data.default_joint_pos.clone(),
                robot.data.default_joint_vel.clone()
            )
            joint_pos += torch.rand_like(joint_pos) * 0.1
            robot.write_joint_state_to_sim(joint_pos, joint_vel)

            # 清除内部缓冲，确保下一帧数据一致
            scene.reset()
            print("[INFO]: 重置机器人状态...")

        # 随机生成扭矩动作，并施加到机器人关节
        efforts = torch.randn_like(robot.data.joint_pos) * 5.0
        robot.set_joint_effort_target(efforts)

        # 将所有实体的新状态（根、关节）写入仿真
        scene.write_data_to_sim()
        # 驱动物理仿真前进一步
        sim.step()

        # 更新计数器
        count += 1
        # 从仿真中拉取最新状态到 scene 缓冲
        scene.update(sim_dt)


def main():
    """脚本入口函数"""
    # 创建仿真配置，指定使用 CPU 或 GPU 等
    sim_cfg = sim_utils.SimulationCfg(device=args_cli.device)
    sim = SimulationContext(sim_cfg)

    # 设置摄像机视角，用于仿真界面渲染
    sim.set_camera_view(
        eye=[2.5, 0.0, 4.0],    # 摄像机位置
        target=[0.0, 0.0, 2.0]   # 摄像机看向的目标点
    )

    # 构造场景配置，指定环境数量与环境间距
    scene_cfg = CartpoleSceneCfg(num_envs=args_cli.num_envs, env_spacing=2.0)
    # 创建 InteractiveScene 对象，自动根据 cfg 在场景中实例化所有 prims
    scene = InteractiveScene(scene_cfg)

    # 重置仿真到初始状态
    sim.reset()
    print("[INFO]: 场景搭建完成，开始运行仿真...")

    # 进入仿真主循环
    run_simulator(sim, scene)


if __name__ == "__main__":
    # 执行主函数
    main()
    # 关闭 Omniverse GUI 应用并释放资源
    simulation_app.close()

```



==代码解读==：

- **自动化 vs 手动编写**
    
    - **InteractiveSceneCfg + InteractiveScene**：
        
        - 只要在配置类里用几个字段声明「我要哪些资产」、它们的 USD 路径模板和 spawn 配置，外加两个参数 `num_envs`（环境数量）和 `env_spacing`（环境间距），框架就会帮你：
            
            1. 根据环境数量在 USD 场景里自动生成对应的命名空间（`/World/Env_0`, `/World/Env_1` …）
                
            2. 把所有声明的资产（地面、灯光、机器人）在每个环境下实例化
                
            3. 在仿真循环中统一管理写入和更新（`scene.write_data_to_sim()` / `scene.update()`）
                
        - **优点**：少写循环、少写路径拼接、少写实例化流程。
            
        - **可扩展性**：新增一个资产，只要在配置类里再加一个字段即可，原有逻辑零改动。
            
    - **手写 `design_scene()` 函数**：
        
        - 你得自己写循环：
            
            ```python
            for i in range(num_envs):
                prim_path = f"/World/Env_{i}/Robot"
                loader = sim_utils.load_articulation(CARTPOLE_PATH, prim_path=prim_path)
                …
            ```
            
        - 每个资产的实例化、命名空间管理、参数暴露都需要在函数里显式硬编码并维护。
            
        - **维护成本**：后期要加更多资产、新的参数、改命名空间逻辑，都得改函数体，一不小心就把循环逻辑弄错。
            
- **总结区别**
    
| 方面       | InteractiveSceneCfg             | 手写 design_scene()     |
| -------- | ------------------------------- | --------------------- |
| 代码量      | 少：只声明配置，自动完成循环/实例化              | 多：显式写循环、路径拼接、spawn 调用 |
| 可读性/可维护性 | 高：配置集中、字段一目了然                   | 较低：逻辑分散在函数里           |
| 扩展新资产    | 简单：新增字段即可                       | 较麻烦：要改循环逻辑和参数传递       |
| 并行环境管理   | 框架自动：`env_origins`、命名空间、批量写入/更新 | 需要手动管理：位置偏移、更新各自状态    |
    

因此，使用 `InteractiveSceneCfg` 最大的好处是：**一行参数化的配置**就能生成任意数量的、结构一致的并行环境，把「怎么放／怎么刷出」的细节都交给框架，实现快速、干净、易扩展的场景搭建。

在使用 `interactivescenecfg` 做自定义资产（custom assets）放置时，你只需在 spawn 配置里定义好以下核心要素：

1. **资产类型**（asset type）
    
2. **数量**（count）
    
3. **放置约束**（placement constraints，比如最小/最大距离、高度范围、碰撞检测）
    

之后，`interactivescenecfg` 会自动根据各个场景里预先标注好的“锚点”或“可放置区域”（如地面、墙面、桌面等 surface definitions）来选取适合的具体位置并摆放模型。

这样做的好处有：

- **免去了为每个场景手动打点**，大幅提升效率
    
- **统一管理所有环境的放置逻辑**，便于维护和扩展
    
- **可复用性强**：同一套 spawn 配置可以在室内、室外、复杂地形等多种环境下直接使用
    

只要你的 spawn 配置写得规范（确保定义了必要的约束条件），就能让 `interactivescenecfg` 帮你自动“找位置、验碰撞、排重叠”并完成摆放。

如果你在某些特殊环境下需要更细粒度的控制，也可以在 spawn 配置中加上自定义标签（tags）或权重（weights），来影响物体更偏好放在某些特定区域。

总之，不必手动给每个场景写一堆坐标，spawn + interactivescenecfg 就能帮你搞定一切。


---
# 创建基于管理器的基础环境
[创建基于管理器的基础环境 — Isaac Lab 文档](https://docs.robotsfan.com/isaaclab/source/tutorials/03_envs/create_manager_base_env.html)
环境（Environments）将仿真的不同要素（如场景、观测与动作空间、重置事件等）整合起来，为各类应用提供统一的交互接口。在Isaac Lab中，基于管理器的环境通过`envs.ManagerBasedEnv`和`envs.ManagerBasedRLEnv`两类实现。二者高度相似，但`envs.ManagerBasedRLEnv`专为强化学习任务设计，包含奖励函数、终止条件、课程学习及指令生成机制；而`envs.ManagerBasedEnv`则适用于传统机器人控制，不涉及奖励与终止逻辑。

本教程将重点解析基础类`envs.ManagerBasedEnv`及其配套配置类`envs.ManagerBasedEnvCfg`在基于管理器的工作流中的应用。我们将以早前介绍的倒立摆（cartpole）环境为例，详细说明构建新`envs.ManagerBasedEnv`环境时涉及的各个组件。


```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""
This script demonstrates how to create a simple environment with a cartpole. It combines the concepts of
scene, action, observation and event managers to create an environment.

.. code-block:: bash

    ./isaaclab.sh -p scripts/tutorials/03_envs/create_cartpole_base_env.py --num_envs 32

"""

# 提示：首先需要启动 Isaac Sim 仿真器

import argparse  # 导入命令行参数解析模块

from isaaclab.app import AppLauncher  # 从 isaaclab.app 中引入 AppLauncher，用于启动仿真应用

# ====== 命令行参数定义 ======
parser = argparse.ArgumentParser(description="Tutorial on creating a cartpole base environment.")  # 创建参数解析器
parser.add_argument("--num_envs", type=int, default=16, help="Number of environments to spawn.")  # 添加 num_envs 参数，用于指定环境数量

# 将 AppLauncher 自带的 CLI 参数附加到 parser
AppLauncher.add_app_launcher_args(parser)
# 解析命令行传入的所有参数
args_cli = parser.parse_args()

# ====== 启动仿真应用 ======
app_launcher = AppLauncher(args_cli)  # 使用解析后的参数初始化 AppLauncher
simulation_app = app_launcher.app       # 获取底层仿真器实例

"""接下来的逻辑都在仿真器启动之后执行"""

import math  # 导入数学库
import torch # 导入 PyTorch，用于张量运算和随机数采样

# 导入 ISAAC Lab 中的 MDP、环境、管理器等核心模块
import isaaclab.envs.mdp as mdp
from isaaclab.envs import ManagerBasedEnv, ManagerBasedEnvCfg
from isaaclab.managers import EventTermCfg as EventTerm
from isaaclab.managers import ObservationGroupCfg as ObsGroup
from isaaclab.managers import ObservationTermCfg as ObsTerm
from isaaclab.managers import SceneEntityCfg
from isaaclab.utils import configclass

# 导入任务配置——小车倒立摆场景配置
from isaaclab_tasks.manager_based.classic.cartpole.cartpole_env_cfg import CartpoleSceneCfg


@configclass
class ActionsCfg:
    """动作配置：定义智能体可执行的动作空间"""

    # 定义一个关节力矩类型的动作，针对机器人（资产名 robot）中的 slider_to_cart 关节
    joint_efforts = mdp.JointEffortActionCfg(
	    asset_name="robot", 
	    joint_names=["slider_to_cart"], 
	    scale=5.0
	    )


@configclass
class ObservationsCfg:
    """观测配置：定义环境对智能体的观测输出"""

    @configclass
    class PolicyCfg(ObsGroup):
        """策略组观测：policy group 下的具体观测项"""

        # 按顺序声明关节相对位置和速度观测
        joint_pos_rel = ObsTerm(func=mdp.joint_pos_rel)  # 相对位置
        joint_vel_rel = ObsTerm(func=mdp.joint_vel_rel)  # 相对速度

        def __post_init__(self) -> None:
            # 禁用观测噪声
            self.enable_corruption = False
            # 将所有观测项拼接为一个向量
            self.concatenate_terms = True

    # 将上述策略组注册为观测配置的一部分
    policy: PolicyCfg = PolicyCfg()


@configclass
class EventCfg:
    """事件配置：定义环境在不同阶段（启动、重置）触发的随机化或重设逻辑"""

    # 启动时随机化杆的质量
    add_pole_mass = EventTerm(
        func=mdp.randomize_rigid_body_mass,  # 使用随机化函数
        mode="startup",                    # 在环境启动阶段触发
        params={
            # 指定要随机化的资产和部件（robot 资产中的 pole 刚体）
            "asset_cfg": SceneEntityCfg("robot", body_names=["pole"]),
            # 质量范围：0.1 到 0.5
            "mass_distribution_params": (0.1, 0.5),
            # 操作类型：加（add）
            "operation": "add",
        },
    )

    # 重置时随机化小车位置和速度
    reset_cart_position = EventTerm(
        func=mdp.reset_joints_by_offset,  # 通过偏移重置关节函数
        mode="reset",                    # 在环境调用 reset() 时触发
        params={
            "asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"]),  # 针对小车滑动关节
            "position_range": (-1.0, 1.0),  # 位置区间
            "velocity_range": (-0.1, 0.1),  # 速度区间
        },
    )

    # 重置时随机化杆与小车之间的关节位置和速度
    reset_pole_position = EventTerm(
        func=mdp.reset_joints_by_offset,
        mode="reset",
        params={
            "asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"]),  # 针对杆铰链关节
            "position_range": (-0.125 * math.pi, 0.125 * math.pi),  # 角度范围 ±0.125π
            "velocity_range": (-0.01 * math.pi, 0.01 * math.pi),    # 角速度范围
        },
    )


@configclass
class CartpoleEnvCfg(ManagerBasedEnvCfg):
    """环境配置：汇总场景、观测、动作和事件的配置，构建完整环境"""

    # 场景配置：实例化倒立摆场景，指定环境数量和间距
    scene = CartpoleSceneCfg(num_envs=1024, env_spacing=2.5)
    # 绑定之前定义的观测、动作、事件配置
    observations = ObservationsCfg()
    actions = ActionsCfg()
    events = EventCfg()

    def __post_init__(self):
        """后置初始化：设置可视化视角、步长、仿真时间步等"""
        # 摄像机视角：眼睛位置
        self.viewer.eye = [4.5, 0.0, 6.0]
        # 镜头焦点位置
        self.viewer.lookat = [0.0, 0.0, 2.0]
        # 步频设置：每 4 个模拟步触发一次环境步，200Hz / 4 = 50Hz
        self.decimation = 4
        # 仿真器时间步长：5ms => 200Hz
        self.sim.dt = 0.005


def main():
    """主函数入口：解析参数、创建环境、循环仿真并打印日志"""
    # 实例化环境配置
    env_cfg = CartpoleEnvCfg()
    # 覆盖命令行参数指定的并行环境数量
    env_cfg.scene.num_envs = args_cli.num_envs
    # 指定仿真设备（CPU/GPU）
    env_cfg.sim.device = args_cli.device
    # 创建基于管理器的环境实例
    env = ManagerBasedEnv(cfg=env_cfg)

    # 启动仿真循环
    count = 0
    while simulation_app.is_running():
        # 禁用梯度计算，提高推理效率
        with torch.inference_mode():
            # 每执行 300 步后重置环境
            if count % 300 == 0:
                count = 0
                env.reset()
                print("-" * 80)
                print("[INFO]: Resetting environment...")
            # 随机采样动作（关节力矩）
            joint_efforts = torch.randn_like(env.action_manager.action)
            # 环境步，返回观测和奖励（此处忽略奖励输出）
            obs, _ = env.step(joint_efforts)
            # 打印第一个环境中杆的角度观测
            print("[Env 0]: Pole joint: ", obs['policy'][0][1].item())
            # 步数计数器 +1
            count += 1

    # 关闭环境资源
    env.close()


if __name__ == "__main__":
    # 如果脚本作为主程序运行，则执行主函数并关闭仿真应用
    main()
    simulation_app.close()

```

1. **`ManagerBasedEnv` 的定位和组成`**

`ManagerBasedEnv`（对应类名 `isaaclab.envs.ManagerBasedEnv`）是一个**传统机器人控制**（非 RL）场景的环境接口封装。它整合了仿真运行、场景初始化与更新、动作下发、观测收集和事件调度等多个模块，为用户提供一个 **一站式** 的 API：

- **场景管理**（`InteractiveScene`）
    
- **动作管理**（`ActionManager`）
    
- **观测管理**（`ObservationManager`）
    
- **事件管理**（`EventManager`）
    

每个管理器背后都有对应的“配置类”（`Config`），负责定义该管理器的具体行为。通过编写或继承这些配置类，用户就可以用极少的代码，快速搭建起功能丰富且**可复用**的仿真环境。

2. **`mdp`是什么？**

```python
import isaaclab.envs.mdp as mdp
```
这个模块（MDP，Markov Decision Process 的缩写）里定义了与强化学习环境息息相关的一系列工具和配置，包括：

- **动作空间**（action）配置类，比如 `JointEffortActionCfg`，用来指定智能体可以对哪些关节施加扭矩以及比例。
    
- **观测（observation）函数**，如 `joint_pos_rel`、`joint_vel_rel`，它们分别用来提取当前关节的相对位置和速度，作为神经网络的输入。
    
- **随机化工具**，例如 `randomize_rigid_body_mass`，可在环境启动或重置时对刚体质量进行随机化。
    
- **重置函数**，比如 `reset_joints_by_offset`，用于在调用 `env.reset()` 时，对关节位置和速度进行采样并设置初始状态。
    

简而言之，`mdp` 模块聚合了所有与环境动态、动作和观测相关的核心函数和配置类型，是构建管理器式环境（ManagerBasedEnv）时的基础工具箱。

3. **观测噪声**

```python
   # 禁用观测噪声
            self.enable_corruption = False
```

在 ISAAC Lab 的默认实现里，`enable_corruption` 这一开关控制的“观测噪声”确实是以**高斯白噪声**（Gaussian white noise）的形式添加到原始观测上的——也就是在每个观测维度上独立采样、零均值、你可以在配置里指定方差大小。

如果你把

```python
self.enable_corruption = True
```

开启了，那么在 `ObsTerm` 内部会执行类似于

```python
obs = true_obs + torch.randn_like(true_obs) * sigma
```

的操作，其中 `sigma`（标准差）是你在上层配置里可以调整的参数。

---

***如何自定义噪声类型

1. **修改 Gaussian 的参数**
    
    - 在 `ObservationTermCfg`（也就是 `ObsTerm`）或 `ObservationGroupCfg` 上通常会有一个 `corruption_std` 或类似字段，你可以直接改它来调整噪声强度。
        
2. **替换采样函数**
    
    - 如果你想用其它分布（比如均匀分布、泊松噪声，甚至是你自定义的任何分布），最简单的方案是继承 `ObservationTermCfg`，重写它内部对噪声的添加逻辑。例如：
        
        ```python
        from isaaclab.managers import ObservationTermCfg
        import torch
        
        class MyCustomObsTerm(ObservationTermCfg):
            def corrupt(self, true_obs):
                # 这里改成均匀分布噪声
                noise = (torch.rand_like(true_obs) - 0.5) * 2.0 * self.uniform_scale
                return true_obs + noise
        ```
        
    - 然后在你的 `ObsGroup` 中把原来的 `ObsTerm(...)` 换成 `MyCustomObsTerm(...)`。
        
3. **在 ObservationGroupCfg 里集中控制**
    
    - 如果你想对一个观测组里所有项统一换噪声策略，也可以在 `ObservationGroupCfg`（这里是 `PolicyCfg`）里添加一个钩子，统一拦截并污染 `obs_dict`。
        

---

这样你就能在同一个环境中灵活切换、调试各种噪声模型了。


4. **注册观测配置**
	在这里：
	
```python
policy: PolicyCfg = PolicyCfg()
```

你看到的 `policy:` 并不是某个特殊的关键字，而是 Python 里的类型注解（type hint）语法，它完成了两件事：

1. **声明属性名称和类型**
    
    - `policy` 是 `ObservationsCfg` 这个配置类里的一个字段（attribute）名字。
        
    - `: PolicyCfg` 告诉 Python（以及静态类型检查器、IDE）——“这个字段的类型是 `PolicyCfg`”。
        
2. **提供默认实例**
    
    - `= PolicyCfg()` 则是在创建 `ObservationsCfg` 的时候，给 `policy` 字段一个默认值：一个新的 `PolicyCfg` 对象。
        

整行代码等价于在一个普通 Python 类里写：

```python
class ObservationsCfg:
    # 声明一个名为 policy 的成员，类型是 PolicyCfg，默认值是 PolicyCfg()
    policy: PolicyCfg = PolicyCfg()
```

在 ISAAC Lab 的配置系统中，所有子配置（像动作、观测组、事件组）都通过这种「字段＝子配置实例」的方式进行挂载。这样，当外部去扫描或序列化 `ObservationsCfg` 时，就能自动发现 `policy` 这一组观测，并将它纳入到环境的观测管线里。

------------

5. **事件配置**

```python
  # 启动时随机化杆的质量
    add_pole_mass = EventTerm(
        func=mdp.randomize_rigid_body_mass,  # 使用随机化函数
        mode="startup",                    # 在环境启动阶段触发
        params={
            # 指定要随机化的资产和部件（robot 资产中的 pole 刚体）
            "asset_cfg": SceneEntityCfg("robot", body_names=["pole"]),
            # 质量范围：0.1 到 0.5
            "mass_distribution_params": (0.1, 0.5),
            # 操作类型：加（add）
            "operation": "add",
        },
    )
```
使用`Eventerm`注册了一个事件变量`add_pole_mass`，并指定其执行函数`func`，启动模式`mode`，以及给执行函数`mdp.randomize_rigid_body_mass`传入对应的参数字典。

`func`也支持自定义的函数类型只要满足以下要求：

- 回调函数（`func`）的第一个形参必须是环境对象；
    
- 后面的形参名称要和 `params` 字典里的键一一对应，或者用 `**kwargs` 一次性接收所有；
    
- 参数顺序：环境对象放第一位，其余可以自由排列，只要名字对得上就行；
    
- 如果定义了默认值，可选参数就可不写在 `params` 里。


`mode`可以有很多类型，不同的 `mode` 控制你的函数在何时被触发。常见的模式包括：

- `startup`：环境初始化阶段触发，一般用来做一次性设置。
    
- `pre_step` / `pre_physics`：每个物理子步（physics substep）之前调用。
    
- `post_step` / `post_physics`：每个物理子步之后调用。
    
- `on_action`：Agent 发出动作后立刻触发，常用于对动作进行后处理。
    
- `on_event`：对特定环境事件（比如碰撞、触地）做响应。


---------
# 创建基于管理器的强化学习环境
在学习了《[[#创建基于管理器的基础环境]]》中如何构建基环境后，我们现在将探讨如何为强化学习创建基于管理器的任务环境。

基环境被设计为"`感知-行动`"环境，智能体可向环境发送指令并接收环境反馈。这种极简接口足以满足传统运动规划与控制等许多应用需求。但对于需要明确任务目标的场景（通常作为智能体的学习目标），例如导航任务中要求抵达目标位置，我们需通过继承基环境的`envs.ManagerBasedRLEnv`类来扩展任务规范功能。

与`Isaac Lab`其他组件一致，我们不建议直接修改`envs.ManagerBasedRLEnv`基类，而是鼓励用户通过配置`envs.ManagerBasedRLEnvCfg`来实现任务环境。这种设计模式能将任务规范与环境实现解耦，便于复用同一环境的不同任务组件。

本教程将使用`envs.ManagerBasedRLEnvCfg`配置倒立摆环境，创建"保持竖直平衡"的基于管理器的任务。我们将学习如何通过奖励条件、终止标准、课程学习机制和指令系统来定义任务规范。


## `cartpole_env_cfg.py`代码

```python
# Copyright (c) 2022-2025, The Isaac Lab Project Developers.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

import math  # 导入数学库，用于计算角度等数学函数

import isaaclab.sim as sim_utils  # 导入 isaaclab 模块下的模拟工具
from isaaclab.assets import ArticulationCfg, AssetBaseCfg  # 导入关节配置和基础资源配置类
from isaaclab.envs import ManagerBasedRLEnvCfg  # 导入基于管理器的强化学习环境配置类
from isaaclab.managers import EventTermCfg as EventTerm  # 导入事件管理器配置（重命名为 EventTerm）
from isaaclab.managers import ObservationGroupCfg as ObsGroup  # 导入观测组配置（重命名为 ObsGroup）
from isaaclab.managers import ObservationTermCfg as ObsTerm  # 导入单项观测配置（重命名为 ObsTerm）
from isaaclab.managers import RewardTermCfg as RewTerm  # 导入奖励项配置（重命名为 RewTerm）
from isaaclab.managers import SceneEntityCfg  # 导入场景实体配置
from isaaclab.managers import TerminationTermCfg as DoneTerm  # 导入终止条件配置（重命名为 DoneTerm）
from isaaclab.scene import InteractiveSceneCfg  # 导入交互式场景配置
from isaaclab.utils import configclass  # 导入配置装饰器，用于定义配置类

import isaaclab_tasks.manager_based.classic.cartpole.mdp as mdp  # 导入与 cartpole MDP 相关的功能函数

##
# 预定义资源
##
from isaaclab_assets.robots.cartpole import CARTPOLE_CFG  # 导入预设的 cartpole 机器人配置  # isort:skip


##
# 场景定义
##

@configclass
class CartpoleSceneCfg(InteractiveSceneCfg):
    """Cart-pole 场景配置。"""

    # 地面平面资源
    ground = AssetBaseCfg(
        prim_path="/World/ground",  # 在 USD 场景中的路径
        spawn=sim_utils.GroundPlaneCfg(size=(100.0, 100.0)),  # 生成一个大尺寸地面
    )

    # 小车-杆系统机器人资源
    robot: ArticulationCfg = CARTPOLE_CFG.replace(prim_path="{ENV_REGEX_NS}/Robot")  # 使用预设的 CARTPOLE_CFG，并替换路径

    # 场景光照
    dome_light = AssetBaseCfg(
        prim_path="/World/DomeLight",  # 杂光灯路径
        spawn=sim_utils.DomeLightCfg(color=(0.9, 0.9, 0.9), intensity=500.0),  # 设置光照颜色和强度
    )


##
# MDP 设置
##

@configclass
class ActionsCfg:
    """MDP 的动作配置。"""

    # 定义关节扭矩动作，作用于 slider_to_cart 关节，缩放参数为 100
    joint_effort = mdp.JointEffortActionCfg(asset_name="robot", joint_names=["slider_to_cart"], scale=100.0)


@configclass
class ObservationsCfg:
    """MDP 的观测配置。"""

    @configclass
    class PolicyCfg(ObsGroup):
        """策略网络使用的观测组。"""

        # 定义观测项，按照顺序保留
        joint_pos_rel = ObsTerm(func=mdp.joint_pos_rel)  # 相对关节位置
        joint_vel_rel = ObsTerm(func=mdp.joint_vel_rel)  # 相对关节速度

        def __post_init__(self) -> None:
            # 是否开启观测腐蚀（噪声），以及是否将多项观测拼接成一个向量
            self.enable_corruption = False
            self.concatenate_terms = True

    # 注册观测组实例
    policy: PolicyCfg = PolicyCfg()


@configclass
class EventCfg:
    """事件（重置等）配置。"""

    # 重置小车位置事件：随机偏移 slider_to_cart 关节位置及速度
    reset_cart_position = EventTerm(
        func=mdp.reset_joints_by_offset,
        mode="reset",
        params={
            "asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"]),
            "position_range": (-1.0, 1.0),
            "velocity_range": (-0.5, 0.5),
        },
    )

    # 重置杆的位置事件：随机偏移 cart_to_pole 关节位置及速度
    reset_pole_position = EventTerm(
        func=mdp.reset_joints_by_offset,
        mode="reset",
        params={
            "asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"]),
            "position_range": (-0.25 * math.pi, 0.25 * math.pi),  # 以弧度为单位
            "velocity_range": (-0.25 * math.pi, 0.25 * math.pi),
        },
    )


@configclass
class RewardsCfg:
    """MDP 的奖励配置。"""

    # (1) 存活奖励：每步 +1
    alive = RewTerm(func=mdp.is_alive, weight=1.0)
    # (2) 终止惩罚：失败时 -2
    terminating = RewTerm(func=mdp.is_terminated, weight=-2.0)
    # (3) 主任务奖励：杆保持直立（L2 距离到目标角度 0）
    pole_pos = RewTerm(
        func=mdp.joint_pos_target_l2,
        weight=-1.0,
        params={"asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"]), "target": 0.0},
    )
    # (4) 形状奖励：降低小车速度（L1 速度）
    cart_vel = RewTerm(
        func=mdp.joint_vel_l1,
        weight=-0.01,
        params={"asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"] )},
    )
    # (5) 形状奖励：降低杆的角速度（L1 速度）
    pole_vel = RewTerm(
        func=mdp.joint_vel_l1,
        weight=-0.005,
        params={"asset_cfg": SceneEntityCfg("robot", joint_names=["cart_to_pole"] )},
    )


@configclass
class TerminationsCfg:
    """MDP 的终止条件配置。"""

    # (1) 超时终止：达到最大步数
    time_out = DoneTerm(func=mdp.time_out, time_out=True)
    # (2) 小车超出边界终止
    cart_out_of_bounds = DoneTerm(
        func=mdp.joint_pos_out_of_manual_limit,
        params={"asset_cfg": SceneEntityCfg("robot", joint_names=["slider_to_cart"]), "bounds": (-3.0, 3.0)},
    )


##
# 环境总配置
##

@configclass
class CartpoleEnvCfg(ManagerBasedRLEnvCfg):
    """完整的 cartpole 强化学习环境配置。"""

    # 场景设置：4096 个并行环境，间距 4 米
    scene: CartpoleSceneCfg = CartpoleSceneCfg(num_envs=4096, env_spacing=4.0)
    # 基本设置
    observations: ObservationsCfg = ObservationsCfg()
    actions: ActionsCfg = ActionsCfg()
    events: EventCfg = EventCfg()
    # MDP 细节
    rewards: RewardsCfg = RewardsCfg()
    terminations: TerminationsCfg = TerminationsCfg()

    def __post_init__(self) -> None:
        """后初始化，设置额外参数。"""
        # 仿真频率与精度：每步 1/120 秒，仿真下采样率为 2
        self.decimation = 2
        self.episode_length_s = 5  # 最大每集时长 5 秒
        # 查看器视角配置
        self.viewer.eye = (8.0, 0.0, 5.0)
        # 仿真相关设置
        self.sim.dt = 1 / 120  # 时间步长
        self.sim.render_interval = self.decimation  # 渲染间隔

```

